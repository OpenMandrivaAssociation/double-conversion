From 2c290755e7f06f721ab8aa9d602e3bd625a8303c Mon Sep 17 00:00:00 2001
From: "Dr. Colin Hirsch" <colinh-github-06134@icemx.net>
Date: Tue, 11 Jun 2019 18:03:15 +0200
Subject: [PATCH 02/24] Consistent macro prefix. (#101)

Consistent macro prefix.
---
 Changelog                              |   3 +
 double-conversion/bignum-dtoa.cc       |  34 ++---
 double-conversion/bignum.cc            |  86 +++++------
 double-conversion/bignum.h             |   4 +-
 double-conversion/cached-powers.cc     | 188 ++++++++++++-------------
 double-conversion/diy-fp.h             |  10 +-
 double-conversion/double-conversion.cc |  72 +++++-----
 double-conversion/double-conversion.h  |   6 +-
 double-conversion/fast-dtoa.cc         |  54 +++----
 double-conversion/fixed-dtoa.cc        |  20 +--
 double-conversion/ieee.h               |  34 ++---
 double-conversion/strtod.cc            |  60 ++++----
 double-conversion/utils.h              |  66 ++++-----
 test/cctest/checks.h                   |  46 +++---
 test/cctest/test-bignum-dtoa.cc        |   4 +-
 test/cctest/test-bignum.cc             |  32 ++---
 test/cctest/test-conversions.cc        |  18 +--
 test/cctest/test-diy-fp.cc             |  12 +-
 test/cctest/test-dtoa.cc               |   4 +-
 test/cctest/test-fast-dtoa.cc          |   8 +-
 test/cctest/test-ieee.cc               |  56 ++++----
 21 files changed, 410 insertions(+), 407 deletions(-)

diff --git a/Changelog b/Changelog
index 606f47f..b454d8b 100644
--- a/Changelog
+++ b/Changelog
@@ -1,3 +1,6 @@
+2019-06-11:
+  Changed all macros to use DOUBLE_CONVERSION_ as prefix.
+
 2019-05-25:
   Fix `0x` for string->double conversion when Hex Floats are allowed.
   Avoid integer overflow when exponents for hex floats were too big.
diff --git a/double-conversion/bignum-dtoa.cc b/double-conversion/bignum-dtoa.cc
index d99ac2a..2b8f9ec 100644
--- a/double-conversion/bignum-dtoa.cc
+++ b/double-conversion/bignum-dtoa.cc
@@ -35,7 +35,7 @@
 namespace double_conversion {
 
 static int NormalizedExponent(uint64_t significand, int exponent) {
-  ASSERT(significand != 0);
+  DOUBLE_CONVERSION_ASSERT(significand != 0);
   while ((significand & Double::kHiddenBit) == 0) {
     significand = significand << 1;
     exponent = exponent - 1;
@@ -88,14 +88,14 @@ static void GenerateCountedDigits(int count, int* decimal_point,
 
 void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,
                 Vector<char> buffer, int* length, int* decimal_point) {
-  ASSERT(v > 0);
-  ASSERT(!Double(v).IsSpecial());
+  DOUBLE_CONVERSION_ASSERT(v > 0);
+  DOUBLE_CONVERSION_ASSERT(!Double(v).IsSpecial());
   uint64_t significand;
   int exponent;
   bool lower_boundary_is_closer;
   if (mode == BIGNUM_DTOA_SHORTEST_SINGLE) {
     float f = static_cast<float>(v);
-    ASSERT(f == v);
+    DOUBLE_CONVERSION_ASSERT(f == v);
     significand = Single(f).Significand();
     exponent = Single(f).Exponent();
     lower_boundary_is_closer = Single(f).LowerBoundaryIsCloser();
@@ -134,7 +134,7 @@ void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,
   // 4e-324. In this case the denominator needs fewer than 324*4 binary digits.
   // The maximum double is 1.7976931348623157e308 which needs fewer than
   // 308*4 binary digits.
-  ASSERT(Bignum::kMaxSignificantBits >= 324*4);
+  DOUBLE_CONVERSION_ASSERT(Bignum::kMaxSignificantBits >= 324*4);
   InitialScaledStartValues(significand, exponent, lower_boundary_is_closer,
                            estimated_power, need_boundary_deltas,
                            &numerator, &denominator,
@@ -163,7 +163,7 @@ void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,
                             buffer, length);
       break;
     default:
-      UNREACHABLE();
+      DOUBLE_CONVERSION_UNREACHABLE();
   }
   buffer[*length] = '\0';
 }
@@ -195,7 +195,7 @@ static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
   for (;;) {
     uint16_t digit;
     digit = numerator->DivideModuloIntBignum(*denominator);
-    ASSERT(digit <= 9);  // digit is a uint16_t and therefore always positive.
+    DOUBLE_CONVERSION_ASSERT(digit <= 9);  // digit is a uint16_t and therefore always positive.
     // digit = numerator / denominator (integer division).
     // numerator = numerator % denominator.
     buffer[(*length)++] = static_cast<char>(digit + '0');
@@ -241,7 +241,7 @@ static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
         // loop would have stopped earlier.
         // We still have an assert here in case the preconditions were not
         // satisfied.
-        ASSERT(buffer[(*length) - 1] != '9');
+        DOUBLE_CONVERSION_ASSERT(buffer[(*length) - 1] != '9');
         buffer[(*length) - 1]++;
       } else {
         // Halfway case.
@@ -252,7 +252,7 @@ static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
         if ((buffer[(*length) - 1] - '0') % 2 == 0) {
           // Round down => Do nothing.
         } else {
-          ASSERT(buffer[(*length) - 1] != '9');
+          DOUBLE_CONVERSION_ASSERT(buffer[(*length) - 1] != '9');
           buffer[(*length) - 1]++;
         }
       }
@@ -264,9 +264,9 @@ static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
       // Round up.
       // Note again that the last digit could not be '9' since this would have
       // stopped the loop earlier.
-      // We still have an ASSERT here, in case the preconditions were not
+      // We still have an DOUBLE_CONVERSION_ASSERT here, in case the preconditions were not
       // satisfied.
-      ASSERT(buffer[(*length) -1] != '9');
+      DOUBLE_CONVERSION_ASSERT(buffer[(*length) -1] != '9');
       buffer[(*length) - 1]++;
       return;
     }
@@ -283,11 +283,11 @@ static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
 static void GenerateCountedDigits(int count, int* decimal_point,
                                   Bignum* numerator, Bignum* denominator,
                                   Vector<char> buffer, int* length) {
-  ASSERT(count >= 0);
+  DOUBLE_CONVERSION_ASSERT(count >= 0);
   for (int i = 0; i < count - 1; ++i) {
     uint16_t digit;
     digit = numerator->DivideModuloIntBignum(*denominator);
-    ASSERT(digit <= 9);  // digit is a uint16_t and therefore always positive.
+    DOUBLE_CONVERSION_ASSERT(digit <= 9);  // digit is a uint16_t and therefore always positive.
     // digit = numerator / denominator (integer division).
     // numerator = numerator % denominator.
     buffer[i] = static_cast<char>(digit + '0');
@@ -300,7 +300,7 @@ static void GenerateCountedDigits(int count, int* decimal_point,
   if (Bignum::PlusCompare(*numerator, *numerator, *denominator) >= 0) {
     digit++;
   }
-  ASSERT(digit <= 10);
+  DOUBLE_CONVERSION_ASSERT(digit <= 10);
   buffer[count - 1] = static_cast<char>(digit + '0');
   // Correct bad digits (in case we had a sequence of '9's). Propagate the
   // carry until we hat a non-'9' or til we reach the first digit.
@@ -341,7 +341,7 @@ static void BignumToFixed(int requested_digits, int* decimal_point,
   } else if (-(*decimal_point) == requested_digits) {
     // We only need to verify if the number rounds down or up.
     // Ex: 0.04 and 0.06 with requested_digits == 1.
-    ASSERT(*decimal_point == -requested_digits);
+    DOUBLE_CONVERSION_ASSERT(*decimal_point == -requested_digits);
     // Initially the fraction lies in range (1, 10]. Multiply the denominator
     // by 10 so that we can compare more easily.
     denominator->Times10();
@@ -420,7 +420,7 @@ static void InitialScaledStartValuesPositiveExponent(
     Bignum* numerator, Bignum* denominator,
     Bignum* delta_minus, Bignum* delta_plus) {
   // A positive exponent implies a positive power.
-  ASSERT(estimated_power >= 0);
+  DOUBLE_CONVERSION_ASSERT(estimated_power >= 0);
   // Since the estimated_power is positive we simply multiply the denominator
   // by 10^estimated_power.
 
@@ -506,7 +506,7 @@ static void InitialScaledStartValuesNegativeExponentNegativePower(
   // numerator = v * 10^-estimated_power * 2 * 2^-exponent.
   // Remember: numerator has been abused as power_ten. So no need to assign it
   //  to itself.
-  ASSERT(numerator == power_ten);
+  DOUBLE_CONVERSION_ASSERT(numerator == power_ten);
   numerator->MultiplyByUInt64(significand);
 
   // denominator = 2 * 2^-exponent with exponent < 0.
diff --git a/double-conversion/bignum.cc b/double-conversion/bignum.cc
index fb5d7e7..7e504fe 100644
--- a/double-conversion/bignum.cc
+++ b/double-conversion/bignum.cc
@@ -48,7 +48,7 @@ static int BitSize(S value) {
 
 // Guaranteed to lie in one Bigit.
 void Bignum::AssignUInt16(uint16_t value) {
-  ASSERT(kBigitSize >= BitSize(value));
+  DOUBLE_CONVERSION_ASSERT(kBigitSize >= BitSize(value));
   Zero();
   if (value == 0) return;
 
@@ -94,7 +94,7 @@ static uint64_t ReadUInt64(Vector<const char> buffer,
   uint64_t result = 0;
   for (int i = from; i < from + digits_to_read; ++i) {
     int digit = buffer[i] - '0';
-    ASSERT(0 <= digit && digit <= 9);
+    DOUBLE_CONVERSION_ASSERT(0 <= digit && digit <= 9);
     result = result * 10 + digit;
   }
   return result;
@@ -125,7 +125,7 @@ void Bignum::AssignDecimalString(Vector<const char> value) {
 static int HexCharValue(char c) {
   if ('0' <= c && c <= '9') return c - '0';
   if ('a' <= c && c <= 'f') return 10 + c - 'a';
-  ASSERT('A' <= c && c <= 'F');
+  DOUBLE_CONVERSION_ASSERT('A' <= c && c <= 'F');
   return 10 + c - 'A';
 }
 
@@ -169,8 +169,8 @@ void Bignum::AddUInt64(uint64_t operand) {
 
 
 void Bignum::AddBignum(const Bignum& other) {
-  ASSERT(IsClamped());
-  ASSERT(other.IsClamped());
+  DOUBLE_CONVERSION_ASSERT(IsClamped());
+  DOUBLE_CONVERSION_ASSERT(other.IsClamped());
 
   // If this has a greater exponent than other append zero-bigits to this.
   // After this call exponent_ <= other.exponent_.
@@ -191,7 +191,7 @@ void Bignum::AddBignum(const Bignum& other) {
   EnsureCapacity(1 + (std::max)(BigitLength(), other.BigitLength()) - exponent_);
   Chunk carry = 0;
   int bigit_pos = other.exponent_ - exponent_;
-  ASSERT(bigit_pos >= 0);
+  DOUBLE_CONVERSION_ASSERT(bigit_pos >= 0);
   for (int i = 0; i < other.used_digits_; ++i) {
     Chunk sum = bigits_[bigit_pos] + other.bigits_[i] + carry;
     bigits_[bigit_pos] = sum & kBigitMask;
@@ -206,15 +206,15 @@ void Bignum::AddBignum(const Bignum& other) {
     bigit_pos++;
   }
   used_digits_ = (std::max)(bigit_pos, used_digits_);
-  ASSERT(IsClamped());
+  DOUBLE_CONVERSION_ASSERT(IsClamped());
 }
 
 
 void Bignum::SubtractBignum(const Bignum& other) {
-  ASSERT(IsClamped());
-  ASSERT(other.IsClamped());
+  DOUBLE_CONVERSION_ASSERT(IsClamped());
+  DOUBLE_CONVERSION_ASSERT(other.IsClamped());
   // We require this to be bigger than other.
-  ASSERT(LessEqual(other, *this));
+  DOUBLE_CONVERSION_ASSERT(LessEqual(other, *this));
 
   Align(other);
 
@@ -222,7 +222,7 @@ void Bignum::SubtractBignum(const Bignum& other) {
   Chunk borrow = 0;
   int i;
   for (i = 0; i < other.used_digits_; ++i) {
-    ASSERT((borrow == 0) || (borrow == 1));
+    DOUBLE_CONVERSION_ASSERT((borrow == 0) || (borrow == 1));
     Chunk difference = bigits_[i + offset] - other.bigits_[i] - borrow;
     bigits_[i + offset] = difference & kBigitMask;
     borrow = difference >> (kChunkSize - 1);
@@ -256,7 +256,7 @@ void Bignum::MultiplyByUInt32(uint32_t factor) {
 
   // The product of a bigit with the factor is of size kBigitSize + 32.
   // Assert that this number + 1 (for the carry) fits into double chunk.
-  ASSERT(kDoubleChunkSize >= kBigitSize + 32 + 1);
+  DOUBLE_CONVERSION_ASSERT(kDoubleChunkSize >= kBigitSize + 32 + 1);
   DoubleChunk carry = 0;
   for (int i = 0; i < used_digits_; ++i) {
     DoubleChunk product = static_cast<DoubleChunk>(factor) * bigits_[i] + carry;
@@ -278,7 +278,7 @@ void Bignum::MultiplyByUInt64(uint64_t factor) {
     Zero();
     return;
   }
-  ASSERT(kBigitSize < 32);
+  DOUBLE_CONVERSION_ASSERT(kBigitSize < 32);
   uint64_t carry = 0;
   uint64_t low = factor & 0xFFFFFFFF;
   uint64_t high = factor >> 32;
@@ -300,7 +300,7 @@ void Bignum::MultiplyByUInt64(uint64_t factor) {
 
 
 void Bignum::MultiplyByPowerOfTen(int exponent) {
-  const uint64_t kFive27 = UINT64_2PART_C(0x6765c793, fa10079d);
+  const uint64_t kFive27 = DOUBLE_CONVERSION_UINT64_2PART_C(0x6765c793, fa10079d);
   const uint16_t kFive1 = 5;
   const uint16_t kFive2 = kFive1 * 5;
   const uint16_t kFive3 = kFive2 * 5;
@@ -318,7 +318,7 @@ void Bignum::MultiplyByPowerOfTen(int exponent) {
       { kFive1, kFive2, kFive3, kFive4, kFive5, kFive6,
         kFive7, kFive8, kFive9, kFive10, kFive11, kFive12 };
 
-  ASSERT(exponent >= 0);
+  DOUBLE_CONVERSION_ASSERT(exponent >= 0);
   if (exponent == 0) return;
   if (used_digits_ == 0) return;
 
@@ -340,7 +340,7 @@ void Bignum::MultiplyByPowerOfTen(int exponent) {
 
 
 void Bignum::Square() {
-  ASSERT(IsClamped());
+  DOUBLE_CONVERSION_ASSERT(IsClamped());
   int product_length = 2 * used_digits_;
   EnsureCapacity(product_length);
 
@@ -357,7 +357,7 @@ void Bignum::Square() {
   // Assert that the additional number of bits in a DoubleChunk are enough to
   // sum up used_digits of Bigit*Bigit.
   if ((1 << (2 * (kChunkSize - kBigitSize))) <= used_digits_) {
-    UNIMPLEMENTED();
+    DOUBLE_CONVERSION_UNIMPLEMENTED();
   }
   DoubleChunk accumulator = 0;
   // First shift the digits so we don't overwrite them.
@@ -402,7 +402,7 @@ void Bignum::Square() {
   }
   // Since the result was guaranteed to lie inside the number the
   // accumulator must be 0 now.
-  ASSERT(accumulator == 0);
+  DOUBLE_CONVERSION_ASSERT(accumulator == 0);
 
   // Don't forget to update the used_digits and the exponent.
   used_digits_ = product_length;
@@ -412,8 +412,8 @@ void Bignum::Square() {
 
 
 void Bignum::AssignPowerUInt16(uint16_t base, int power_exponent) {
-  ASSERT(base != 0);
-  ASSERT(power_exponent >= 0);
+  DOUBLE_CONVERSION_ASSERT(base != 0);
+  DOUBLE_CONVERSION_ASSERT(power_exponent >= 0);
   if (power_exponent == 0) {
     AssignUInt16(1);
     return;
@@ -454,7 +454,7 @@ void Bignum::AssignPowerUInt16(uint16_t base, int power_exponent) {
     // Verify that there is enough space in this_value to perform the
     // multiplication.  The first bit_size bits must be 0.
     if ((power_exponent & mask) != 0) {
-      ASSERT(bit_size > 0);
+      DOUBLE_CONVERSION_ASSERT(bit_size > 0);
       uint64_t base_bits_mask =
           ~((static_cast<uint64_t>(1) << (64 - bit_size)) - 1);
       bool high_bits_zero = (this_value & base_bits_mask) == 0;
@@ -487,9 +487,9 @@ void Bignum::AssignPowerUInt16(uint16_t base, int power_exponent) {
 
 // Precondition: this/other < 16bit.
 uint16_t Bignum::DivideModuloIntBignum(const Bignum& other) {
-  ASSERT(IsClamped());
-  ASSERT(other.IsClamped());
-  ASSERT(other.used_digits_ > 0);
+  DOUBLE_CONVERSION_ASSERT(IsClamped());
+  DOUBLE_CONVERSION_ASSERT(other.IsClamped());
+  DOUBLE_CONVERSION_ASSERT(other.used_digits_ > 0);
 
   // Easy case: if we have less digits than the divisor than the result is 0.
   // Note: this handles the case where this == 0, too.
@@ -507,15 +507,15 @@ uint16_t Bignum::DivideModuloIntBignum(const Bignum& other) {
     // This naive approach is extremely inefficient if `this` divided by other
     // is big. This function is implemented for doubleToString where
     // the result should be small (less than 10).
-    ASSERT(other.bigits_[other.used_digits_ - 1] >= ((1 << kBigitSize) / 16));
-    ASSERT(bigits_[used_digits_ - 1] < 0x10000);
+    DOUBLE_CONVERSION_ASSERT(other.bigits_[other.used_digits_ - 1] >= ((1 << kBigitSize) / 16));
+    DOUBLE_CONVERSION_ASSERT(bigits_[used_digits_ - 1] < 0x10000);
     // Remove the multiples of the first digit.
     // Example this = 23 and other equals 9. -> Remove 2 multiples.
     result += static_cast<uint16_t>(bigits_[used_digits_ - 1]);
     SubtractTimes(other, bigits_[used_digits_ - 1]);
   }
 
-  ASSERT(BigitLength() == other.BigitLength());
+  DOUBLE_CONVERSION_ASSERT(BigitLength() == other.BigitLength());
 
   // Both bignums are at the same length now.
   // Since other has more than 0 digits we know that the access to
@@ -527,14 +527,14 @@ uint16_t Bignum::DivideModuloIntBignum(const Bignum& other) {
     // Shortcut for easy (and common) case.
     int quotient = this_bigit / other_bigit;
     bigits_[used_digits_ - 1] = this_bigit - other_bigit * quotient;
-    ASSERT(quotient < 0x10000);
+    DOUBLE_CONVERSION_ASSERT(quotient < 0x10000);
     result += static_cast<uint16_t>(quotient);
     Clamp();
     return result;
   }
 
   int division_estimate = this_bigit / (other_bigit + 1);
-  ASSERT(division_estimate < 0x10000);
+  DOUBLE_CONVERSION_ASSERT(division_estimate < 0x10000);
   result += static_cast<uint16_t>(division_estimate);
   SubtractTimes(other, division_estimate);
 
@@ -554,7 +554,7 @@ uint16_t Bignum::DivideModuloIntBignum(const Bignum& other) {
 
 template<typename S>
 static int SizeInHexChars(S number) {
-  ASSERT(number > 0);
+  DOUBLE_CONVERSION_ASSERT(number > 0);
   int result = 0;
   while (number != 0) {
     number >>= 4;
@@ -565,16 +565,16 @@ static int SizeInHexChars(S number) {
 
 
 static char HexCharOfValue(int value) {
-  ASSERT(0 <= value && value <= 16);
+  DOUBLE_CONVERSION_ASSERT(0 <= value && value <= 16);
   if (value < 10) return static_cast<char>(value + '0');
   return static_cast<char>(value - 10 + 'A');
 }
 
 
 bool Bignum::ToHexString(char* buffer, int buffer_size) const {
-  ASSERT(IsClamped());
+  DOUBLE_CONVERSION_ASSERT(IsClamped());
   // Each bigit must be printable as separate hex-character.
-  ASSERT(kBigitSize % 4 == 0);
+  DOUBLE_CONVERSION_ASSERT(kBigitSize % 4 == 0);
   const int kHexCharsPerBigit = kBigitSize / 4;
 
   if (used_digits_ == 0) {
@@ -619,8 +619,8 @@ Bignum::Chunk Bignum::BigitAt(int index) const {
 
 
 int Bignum::Compare(const Bignum& a, const Bignum& b) {
-  ASSERT(a.IsClamped());
-  ASSERT(b.IsClamped());
+  DOUBLE_CONVERSION_ASSERT(a.IsClamped());
+  DOUBLE_CONVERSION_ASSERT(b.IsClamped());
   int bigit_length_a = a.BigitLength();
   int bigit_length_b = b.BigitLength();
   if (bigit_length_a < bigit_length_b) return -1;
@@ -637,9 +637,9 @@ int Bignum::Compare(const Bignum& a, const Bignum& b) {
 
 
 int Bignum::PlusCompare(const Bignum& a, const Bignum& b, const Bignum& c) {
-  ASSERT(a.IsClamped());
-  ASSERT(b.IsClamped());
-  ASSERT(c.IsClamped());
+  DOUBLE_CONVERSION_ASSERT(a.IsClamped());
+  DOUBLE_CONVERSION_ASSERT(b.IsClamped());
+  DOUBLE_CONVERSION_ASSERT(c.IsClamped());
   if (a.BigitLength() < b.BigitLength()) {
     return PlusCompare(b, a, c);
   }
@@ -716,15 +716,15 @@ void Bignum::Align(const Bignum& other) {
     }
     used_digits_ += zero_digits;
     exponent_ -= zero_digits;
-    ASSERT(used_digits_ >= 0);
-    ASSERT(exponent_ >= 0);
+    DOUBLE_CONVERSION_ASSERT(used_digits_ >= 0);
+    DOUBLE_CONVERSION_ASSERT(exponent_ >= 0);
   }
 }
 
 
 void Bignum::BigitsShiftLeft(int shift_amount) {
-  ASSERT(shift_amount < kBigitSize);
-  ASSERT(shift_amount >= 0);
+  DOUBLE_CONVERSION_ASSERT(shift_amount < kBigitSize);
+  DOUBLE_CONVERSION_ASSERT(shift_amount >= 0);
   Chunk carry = 0;
   for (int i = 0; i < used_digits_; ++i) {
     Chunk new_carry = bigits_[i] >> (kBigitSize - shift_amount);
@@ -739,7 +739,7 @@ void Bignum::BigitsShiftLeft(int shift_amount) {
 
 
 void Bignum::SubtractTimes(const Bignum& other, int factor) {
-  ASSERT(exponent_ <= other.exponent_);
+  DOUBLE_CONVERSION_ASSERT(exponent_ <= other.exponent_);
   if (factor < 3) {
     for (int i = 0; i < factor; ++i) {
       SubtractBignum(other);
diff --git a/double-conversion/bignum.h b/double-conversion/bignum.h
index 7c289fa..ec2991a 100644
--- a/double-conversion/bignum.h
+++ b/double-conversion/bignum.h
@@ -112,7 +112,7 @@ class Bignum {
 
   void EnsureCapacity(int size) {
     if (size > kBigitCapacity) {
-      UNREACHABLE();
+      DOUBLE_CONVERSION_UNREACHABLE();
     }
   }
   void Align(const Bignum& other);
@@ -136,7 +136,7 @@ class Bignum {
   // The Bignum's value equals value(bigits_) * 2^(exponent_ * kBigitSize).
   int exponent_;
 
-  DC_DISALLOW_COPY_AND_ASSIGN(Bignum);
+  DOUBLE_CONVERSION_DISALLOW_COPY_AND_ASSIGN(Bignum);
 };
 
 }  // namespace double_conversion
diff --git a/double-conversion/cached-powers.cc b/double-conversion/cached-powers.cc
index 8ab281a..c0eef77 100644
--- a/double-conversion/cached-powers.cc
+++ b/double-conversion/cached-powers.cc
@@ -42,93 +42,93 @@ struct CachedPower {
 };
 
 static const CachedPower kCachedPowers[] = {
-  {UINT64_2PART_C(0xfa8fd5a0, 081c0288), -1220, -348},
-  {UINT64_2PART_C(0xbaaee17f, a23ebf76), -1193, -340},
-  {UINT64_2PART_C(0x8b16fb20, 3055ac76), -1166, -332},
-  {UINT64_2PART_C(0xcf42894a, 5dce35ea), -1140, -324},
-  {UINT64_2PART_C(0x9a6bb0aa, 55653b2d), -1113, -316},
-  {UINT64_2PART_C(0xe61acf03, 3d1a45df), -1087, -308},
-  {UINT64_2PART_C(0xab70fe17, c79ac6ca), -1060, -300},
-  {UINT64_2PART_C(0xff77b1fc, bebcdc4f), -1034, -292},
-  {UINT64_2PART_C(0xbe5691ef, 416bd60c), -1007, -284},
-  {UINT64_2PART_C(0x8dd01fad, 907ffc3c), -980, -276},
-  {UINT64_2PART_C(0xd3515c28, 31559a83), -954, -268},
-  {UINT64_2PART_C(0x9d71ac8f, ada6c9b5), -927, -260},
-  {UINT64_2PART_C(0xea9c2277, 23ee8bcb), -901, -252},
-  {UINT64_2PART_C(0xaecc4991, 4078536d), -874, -244},
-  {UINT64_2PART_C(0x823c1279, 5db6ce57), -847, -236},
-  {UINT64_2PART_C(0xc2109436, 4dfb5637), -821, -228},
-  {UINT64_2PART_C(0x9096ea6f, 3848984f), -794, -220},
-  {UINT64_2PART_C(0xd77485cb, 25823ac7), -768, -212},
-  {UINT64_2PART_C(0xa086cfcd, 97bf97f4), -741, -204},
-  {UINT64_2PART_C(0xef340a98, 172aace5), -715, -196},
-  {UINT64_2PART_C(0xb23867fb, 2a35b28e), -688, -188},
-  {UINT64_2PART_C(0x84c8d4df, d2c63f3b), -661, -180},
-  {UINT64_2PART_C(0xc5dd4427, 1ad3cdba), -635, -172},
-  {UINT64_2PART_C(0x936b9fce, bb25c996), -608, -164},
-  {UINT64_2PART_C(0xdbac6c24, 7d62a584), -582, -156},
-  {UINT64_2PART_C(0xa3ab6658, 0d5fdaf6), -555, -148},
-  {UINT64_2PART_C(0xf3e2f893, dec3f126), -529, -140},
-  {UINT64_2PART_C(0xb5b5ada8, aaff80b8), -502, -132},
-  {UINT64_2PART_C(0x87625f05, 6c7c4a8b), -475, -124},
-  {UINT64_2PART_C(0xc9bcff60, 34c13053), -449, -116},
-  {UINT64_2PART_C(0x964e858c, 91ba2655), -422, -108},
-  {UINT64_2PART_C(0xdff97724, 70297ebd), -396, -100},
-  {UINT64_2PART_C(0xa6dfbd9f, b8e5b88f), -369, -92},
-  {UINT64_2PART_C(0xf8a95fcf, 88747d94), -343, -84},
-  {UINT64_2PART_C(0xb9447093, 8fa89bcf), -316, -76},
-  {UINT64_2PART_C(0x8a08f0f8, bf0f156b), -289, -68},
-  {UINT64_2PART_C(0xcdb02555, 653131b6), -263, -60},
-  {UINT64_2PART_C(0x993fe2c6, d07b7fac), -236, -52},
-  {UINT64_2PART_C(0xe45c10c4, 2a2b3b06), -210, -44},
-  {UINT64_2PART_C(0xaa242499, 697392d3), -183, -36},
-  {UINT64_2PART_C(0xfd87b5f2, 8300ca0e), -157, -28},
-  {UINT64_2PART_C(0xbce50864, 92111aeb), -130, -20},
-  {UINT64_2PART_C(0x8cbccc09, 6f5088cc), -103, -12},
-  {UINT64_2PART_C(0xd1b71758, e219652c), -77, -4},
-  {UINT64_2PART_C(0x9c400000, 00000000), -50, 4},
-  {UINT64_2PART_C(0xe8d4a510, 00000000), -24, 12},
-  {UINT64_2PART_C(0xad78ebc5, ac620000), 3, 20},
-  {UINT64_2PART_C(0x813f3978, f8940984), 30, 28},
-  {UINT64_2PART_C(0xc097ce7b, c90715b3), 56, 36},
-  {UINT64_2PART_C(0x8f7e32ce, 7bea5c70), 83, 44},
-  {UINT64_2PART_C(0xd5d238a4, abe98068), 109, 52},
-  {UINT64_2PART_C(0x9f4f2726, 179a2245), 136, 60},
-  {UINT64_2PART_C(0xed63a231, d4c4fb27), 162, 68},
-  {UINT64_2PART_C(0xb0de6538, 8cc8ada8), 189, 76},
-  {UINT64_2PART_C(0x83c7088e, 1aab65db), 216, 84},
-  {UINT64_2PART_C(0xc45d1df9, 42711d9a), 242, 92},
-  {UINT64_2PART_C(0x924d692c, a61be758), 269, 100},
-  {UINT64_2PART_C(0xda01ee64, 1a708dea), 295, 108},
-  {UINT64_2PART_C(0xa26da399, 9aef774a), 322, 116},
-  {UINT64_2PART_C(0xf209787b, b47d6b85), 348, 124},
-  {UINT64_2PART_C(0xb454e4a1, 79dd1877), 375, 132},
-  {UINT64_2PART_C(0x865b8692, 5b9bc5c2), 402, 140},
-  {UINT64_2PART_C(0xc83553c5, c8965d3d), 428, 148},
-  {UINT64_2PART_C(0x952ab45c, fa97a0b3), 455, 156},
-  {UINT64_2PART_C(0xde469fbd, 99a05fe3), 481, 164},
-  {UINT64_2PART_C(0xa59bc234, db398c25), 508, 172},
-  {UINT64_2PART_C(0xf6c69a72, a3989f5c), 534, 180},
-  {UINT64_2PART_C(0xb7dcbf53, 54e9bece), 561, 188},
-  {UINT64_2PART_C(0x88fcf317, f22241e2), 588, 196},
-  {UINT64_2PART_C(0xcc20ce9b, d35c78a5), 614, 204},
-  {UINT64_2PART_C(0x98165af3, 7b2153df), 641, 212},
-  {UINT64_2PART_C(0xe2a0b5dc, 971f303a), 667, 220},
-  {UINT64_2PART_C(0xa8d9d153, 5ce3b396), 694, 228},
-  {UINT64_2PART_C(0xfb9b7cd9, a4a7443c), 720, 236},
-  {UINT64_2PART_C(0xbb764c4c, a7a44410), 747, 244},
-  {UINT64_2PART_C(0x8bab8eef, b6409c1a), 774, 252},
-  {UINT64_2PART_C(0xd01fef10, a657842c), 800, 260},
-  {UINT64_2PART_C(0x9b10a4e5, e9913129), 827, 268},
-  {UINT64_2PART_C(0xe7109bfb, a19c0c9d), 853, 276},
-  {UINT64_2PART_C(0xac2820d9, 623bf429), 880, 284},
-  {UINT64_2PART_C(0x80444b5e, 7aa7cf85), 907, 292},
-  {UINT64_2PART_C(0xbf21e440, 03acdd2d), 933, 300},
-  {UINT64_2PART_C(0x8e679c2f, 5e44ff8f), 960, 308},
-  {UINT64_2PART_C(0xd433179d, 9c8cb841), 986, 316},
-  {UINT64_2PART_C(0x9e19db92, b4e31ba9), 1013, 324},
-  {UINT64_2PART_C(0xeb96bf6e, badf77d9), 1039, 332},
-  {UINT64_2PART_C(0xaf87023b, 9bf0ee6b), 1066, 340},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xfa8fd5a0, 081c0288), -1220, -348},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xbaaee17f, a23ebf76), -1193, -340},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x8b16fb20, 3055ac76), -1166, -332},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xcf42894a, 5dce35ea), -1140, -324},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x9a6bb0aa, 55653b2d), -1113, -316},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xe61acf03, 3d1a45df), -1087, -308},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xab70fe17, c79ac6ca), -1060, -300},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xff77b1fc, bebcdc4f), -1034, -292},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xbe5691ef, 416bd60c), -1007, -284},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x8dd01fad, 907ffc3c), -980, -276},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xd3515c28, 31559a83), -954, -268},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x9d71ac8f, ada6c9b5), -927, -260},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xea9c2277, 23ee8bcb), -901, -252},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xaecc4991, 4078536d), -874, -244},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x823c1279, 5db6ce57), -847, -236},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xc2109436, 4dfb5637), -821, -228},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x9096ea6f, 3848984f), -794, -220},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xd77485cb, 25823ac7), -768, -212},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xa086cfcd, 97bf97f4), -741, -204},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xef340a98, 172aace5), -715, -196},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xb23867fb, 2a35b28e), -688, -188},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x84c8d4df, d2c63f3b), -661, -180},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xc5dd4427, 1ad3cdba), -635, -172},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x936b9fce, bb25c996), -608, -164},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xdbac6c24, 7d62a584), -582, -156},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xa3ab6658, 0d5fdaf6), -555, -148},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xf3e2f893, dec3f126), -529, -140},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xb5b5ada8, aaff80b8), -502, -132},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x87625f05, 6c7c4a8b), -475, -124},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xc9bcff60, 34c13053), -449, -116},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x964e858c, 91ba2655), -422, -108},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xdff97724, 70297ebd), -396, -100},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xa6dfbd9f, b8e5b88f), -369, -92},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xf8a95fcf, 88747d94), -343, -84},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xb9447093, 8fa89bcf), -316, -76},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x8a08f0f8, bf0f156b), -289, -68},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xcdb02555, 653131b6), -263, -60},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x993fe2c6, d07b7fac), -236, -52},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xe45c10c4, 2a2b3b06), -210, -44},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xaa242499, 697392d3), -183, -36},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xfd87b5f2, 8300ca0e), -157, -28},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xbce50864, 92111aeb), -130, -20},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x8cbccc09, 6f5088cc), -103, -12},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xd1b71758, e219652c), -77, -4},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x9c400000, 00000000), -50, 4},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xe8d4a510, 00000000), -24, 12},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xad78ebc5, ac620000), 3, 20},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x813f3978, f8940984), 30, 28},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xc097ce7b, c90715b3), 56, 36},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x8f7e32ce, 7bea5c70), 83, 44},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xd5d238a4, abe98068), 109, 52},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x9f4f2726, 179a2245), 136, 60},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xed63a231, d4c4fb27), 162, 68},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xb0de6538, 8cc8ada8), 189, 76},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x83c7088e, 1aab65db), 216, 84},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xc45d1df9, 42711d9a), 242, 92},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x924d692c, a61be758), 269, 100},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xda01ee64, 1a708dea), 295, 108},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xa26da399, 9aef774a), 322, 116},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xf209787b, b47d6b85), 348, 124},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xb454e4a1, 79dd1877), 375, 132},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x865b8692, 5b9bc5c2), 402, 140},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xc83553c5, c8965d3d), 428, 148},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x952ab45c, fa97a0b3), 455, 156},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xde469fbd, 99a05fe3), 481, 164},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xa59bc234, db398c25), 508, 172},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xf6c69a72, a3989f5c), 534, 180},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xb7dcbf53, 54e9bece), 561, 188},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x88fcf317, f22241e2), 588, 196},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xcc20ce9b, d35c78a5), 614, 204},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x98165af3, 7b2153df), 641, 212},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xe2a0b5dc, 971f303a), 667, 220},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xa8d9d153, 5ce3b396), 694, 228},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xfb9b7cd9, a4a7443c), 720, 236},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xbb764c4c, a7a44410), 747, 244},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x8bab8eef, b6409c1a), 774, 252},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xd01fef10, a657842c), 800, 260},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x9b10a4e5, e9913129), 827, 268},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xe7109bfb, a19c0c9d), 853, 276},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xac2820d9, 623bf429), 880, 284},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x80444b5e, 7aa7cf85), 907, 292},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xbf21e440, 03acdd2d), 933, 300},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x8e679c2f, 5e44ff8f), 960, 308},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xd433179d, 9c8cb841), 986, 316},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0x9e19db92, b4e31ba9), 1013, 324},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xeb96bf6e, badf77d9), 1039, 332},
+  {DOUBLE_CONVERSION_UINT64_2PART_C(0xaf87023b, 9bf0ee6b), 1066, 340},
 };
 
 static const int kCachedPowersOffset = 348;  // -1 * the first decimal_exponent.
@@ -148,11 +148,11 @@ void PowersOfTenCache::GetCachedPowerForBinaryExponentRange(
   int foo = kCachedPowersOffset;
   int index =
       (foo + static_cast<int>(k) - 1) / kDecimalExponentDistance + 1;
-  ASSERT(0 <= index && index < static_cast<int>(ARRAY_SIZE(kCachedPowers)));
+  DOUBLE_CONVERSION_ASSERT(0 <= index && index < static_cast<int>(DOUBLE_CONVERSION_ARRAY_SIZE(kCachedPowers)));
   CachedPower cached_power = kCachedPowers[index];
-  ASSERT(min_exponent <= cached_power.binary_exponent);
+  DOUBLE_CONVERSION_ASSERT(min_exponent <= cached_power.binary_exponent);
   (void) max_exponent;  // Mark variable as used.
-  ASSERT(cached_power.binary_exponent <= max_exponent);
+  DOUBLE_CONVERSION_ASSERT(cached_power.binary_exponent <= max_exponent);
   *decimal_exponent = cached_power.decimal_exponent;
   *power = DiyFp(cached_power.significand, cached_power.binary_exponent);
 }
@@ -161,15 +161,15 @@ void PowersOfTenCache::GetCachedPowerForBinaryExponentRange(
 void PowersOfTenCache::GetCachedPowerForDecimalExponent(int requested_exponent,
                                                         DiyFp* power,
                                                         int* found_exponent) {
-  ASSERT(kMinDecimalExponent <= requested_exponent);
-  ASSERT(requested_exponent < kMaxDecimalExponent + kDecimalExponentDistance);
+  DOUBLE_CONVERSION_ASSERT(kMinDecimalExponent <= requested_exponent);
+  DOUBLE_CONVERSION_ASSERT(requested_exponent < kMaxDecimalExponent + kDecimalExponentDistance);
   int index =
       (requested_exponent + kCachedPowersOffset) / kDecimalExponentDistance;
   CachedPower cached_power = kCachedPowers[index];
   *power = DiyFp(cached_power.significand, cached_power.binary_exponent);
   *found_exponent = cached_power.decimal_exponent;
-  ASSERT(*found_exponent <= requested_exponent);
-  ASSERT(requested_exponent < *found_exponent + kDecimalExponentDistance);
+  DOUBLE_CONVERSION_ASSERT(*found_exponent <= requested_exponent);
+  DOUBLE_CONVERSION_ASSERT(requested_exponent < *found_exponent + kDecimalExponentDistance);
 }
 
 }  // namespace double_conversion
diff --git a/double-conversion/diy-fp.h b/double-conversion/diy-fp.h
index 2edf346..2e1ae2c 100644
--- a/double-conversion/diy-fp.h
+++ b/double-conversion/diy-fp.h
@@ -49,8 +49,8 @@ class DiyFp {
   // must be bigger than the significand of other.
   // The result will not be normalized.
   void Subtract(const DiyFp& other) {
-    ASSERT(e_ == other.e_);
-    ASSERT(f_ >= other.f_);
+    DOUBLE_CONVERSION_ASSERT(e_ == other.e_);
+    DOUBLE_CONVERSION_ASSERT(f_ >= other.f_);
     f_ -= other.f_;
   }
 
@@ -75,13 +75,13 @@ class DiyFp {
   }
 
   void Normalize() {
-    ASSERT(f_ != 0);
+    DOUBLE_CONVERSION_ASSERT(f_ != 0);
     uint64_t significand = f_;
     int exponent = e_;
 
     // This method is mainly called for normalizing boundaries. In general
     // boundaries need to be shifted by 10 bits. We thus optimize for this case.
-    const uint64_t k10MSBits = UINT64_2PART_C(0xFFC00000, 00000000);
+    const uint64_t k10MSBits = DOUBLE_CONVERSION_UINT64_2PART_C(0xFFC00000, 00000000);
     while ((significand & k10MSBits) == 0) {
       significand <<= 10;
       exponent -= 10;
@@ -107,7 +107,7 @@ class DiyFp {
   void set_e(int new_value) { e_ = new_value; }
 
  private:
-  static const uint64_t kUint64MSB = UINT64_2PART_C(0x80000000, 00000000);
+  static const uint64_t kUint64MSB = DOUBLE_CONVERSION_UINT64_2PART_C(0x80000000, 00000000);
 
   uint64_t f_;
   int e_;
diff --git a/double-conversion/double-conversion.cc b/double-conversion/double-conversion.cc
index be15a22..bede45c 100644
--- a/double-conversion/double-conversion.cc
+++ b/double-conversion/double-conversion.cc
@@ -79,7 +79,7 @@ void DoubleToStringConverter::CreateExponentialRepresentation(
     int length,
     int exponent,
     StringBuilder* result_builder) const {
-  ASSERT(length != 0);
+  DOUBLE_CONVERSION_ASSERT(length != 0);
   result_builder->AddCharacter(decimal_digits[0]);
   if (length != 1) {
     result_builder->AddCharacter('.');
@@ -98,7 +98,7 @@ void DoubleToStringConverter::CreateExponentialRepresentation(
     result_builder->AddCharacter('0');
     return;
   }
-  ASSERT(exponent < 1e4);
+  DOUBLE_CONVERSION_ASSERT(exponent < 1e4);
   const int kMaxExponentLength = 5;
   char buffer[kMaxExponentLength + 1];
   buffer[kMaxExponentLength] = '\0';
@@ -125,7 +125,7 @@ void DoubleToStringConverter::CreateDecimalRepresentation(
     if (digits_after_point > 0) {
       result_builder->AddCharacter('.');
       result_builder->AddPadding('0', -decimal_point);
-      ASSERT(length <= digits_after_point - (-decimal_point));
+      DOUBLE_CONVERSION_ASSERT(length <= digits_after_point - (-decimal_point));
       result_builder->AddSubstring(decimal_digits, length);
       int remaining_digits = digits_after_point - (-decimal_point) - length;
       result_builder->AddPadding('0', remaining_digits);
@@ -140,10 +140,10 @@ void DoubleToStringConverter::CreateDecimalRepresentation(
     }
   } else {
     // "decima.l_rep000".
-    ASSERT(digits_after_point > 0);
+    DOUBLE_CONVERSION_ASSERT(digits_after_point > 0);
     result_builder->AddSubstring(decimal_digits, decimal_point);
     result_builder->AddCharacter('.');
-    ASSERT(length - decimal_point <= digits_after_point);
+    DOUBLE_CONVERSION_ASSERT(length - decimal_point <= digits_after_point);
     result_builder->AddSubstring(&decimal_digits[decimal_point],
                                  length - decimal_point);
     int remaining_digits = digits_after_point - (length - decimal_point);
@@ -164,7 +164,7 @@ bool DoubleToStringConverter::ToShortestIeeeNumber(
     double value,
     StringBuilder* result_builder,
     DoubleToStringConverter::DtoaMode mode) const {
-  ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE);
+  DOUBLE_CONVERSION_ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE);
   if (Double(value).IsSpecial()) {
     return HandleSpecialValues(value, result_builder);
   }
@@ -201,7 +201,7 @@ bool DoubleToStringConverter::ToShortestIeeeNumber(
 bool DoubleToStringConverter::ToFixed(double value,
                                       int requested_digits,
                                       StringBuilder* result_builder) const {
-  ASSERT(kMaxFixedDigitsBeforePoint == 60);
+  DOUBLE_CONVERSION_ASSERT(kMaxFixedDigitsBeforePoint == 60);
   const double kFirstNonFixed = 1e60;
 
   if (Double(value).IsSpecial()) {
@@ -249,7 +249,7 @@ bool DoubleToStringConverter::ToExponential(
   bool sign;
   // Add space for digit before the decimal point and the '\0' character.
   const int kDecimalRepCapacity = kMaxExponentialDigits + 2;
-  ASSERT(kDecimalRepCapacity > kBase10MaximalLength);
+  DOUBLE_CONVERSION_ASSERT(kDecimalRepCapacity > kBase10MaximalLength);
   char decimal_rep[kDecimalRepCapacity];
 #ifndef NDEBUG
   // Problem: there is an assert in StringBuilder::AddSubstring() that
@@ -267,7 +267,7 @@ bool DoubleToStringConverter::ToExponential(
     DoubleToAscii(value, PRECISION, requested_digits + 1,
                   decimal_rep, kDecimalRepCapacity,
                   &sign, &decimal_rep_length, &decimal_point);
-    ASSERT(decimal_rep_length <= requested_digits + 1);
+    DOUBLE_CONVERSION_ASSERT(decimal_rep_length <= requested_digits + 1);
 
     for (int i = decimal_rep_length; i < requested_digits + 1; ++i) {
       decimal_rep[i] = '0';
@@ -311,7 +311,7 @@ bool DoubleToStringConverter::ToPrecision(double value,
   DoubleToAscii(value, PRECISION, precision,
                 decimal_rep, kDecimalRepCapacity,
                 &sign, &decimal_rep_length, &decimal_point);
-  ASSERT(decimal_rep_length <= precision);
+  DOUBLE_CONVERSION_ASSERT(decimal_rep_length <= precision);
 
   bool unique_zero = ((flags_ & UNIQUE_ZERO) != 0);
   if (sign && (value != 0.0 || !unique_zero)) {
@@ -355,7 +355,7 @@ static BignumDtoaMode DtoaToBignumDtoaMode(
     case DoubleToStringConverter::FIXED:     return BIGNUM_DTOA_FIXED;
     case DoubleToStringConverter::PRECISION: return BIGNUM_DTOA_PRECISION;
     default:
-      UNREACHABLE();
+      DOUBLE_CONVERSION_UNREACHABLE();
   }
 }
 
@@ -369,8 +369,8 @@ void DoubleToStringConverter::DoubleToAscii(double v,
                                             int* length,
                                             int* point) {
   Vector<char> vector(buffer, buffer_length);
-  ASSERT(!Double(v).IsSpecial());
-  ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE || requested_digits >= 0);
+  DOUBLE_CONVERSION_ASSERT(!Double(v).IsSpecial());
+  DOUBLE_CONVERSION_ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE || requested_digits >= 0);
 
   if (Double(v).Sign() < 0) {
     *sign = true;
@@ -411,7 +411,7 @@ void DoubleToStringConverter::DoubleToAscii(double v,
       break;
     default:
       fast_worked = false;
-      UNREACHABLE();
+      DOUBLE_CONVERSION_UNREACHABLE();
   }
   if (fast_worked) return;
 
@@ -439,7 +439,7 @@ static inline bool ConsumeSubStringImpl(Iterator* current,
                                         Iterator end,
                                         const char* substring,
                                         Converter converter) {
-  ASSERT(converter(**current) == *substring);
+  DOUBLE_CONVERSION_ASSERT(converter(**current) == *substring);
   for (substring++; *substring != '\0'; substring++) {
     ++*current;
     if (*current == end || converter(**current) != *substring) {
@@ -483,14 +483,14 @@ const int kMaxSignificantDigits = 772;
 
 
 static const char kWhitespaceTable7[] = { 32, 13, 10, 9, 11, 12 };
-static const int kWhitespaceTable7Length = ARRAY_SIZE(kWhitespaceTable7);
+static const int kWhitespaceTable7Length = DOUBLE_CONVERSION_ARRAY_SIZE(kWhitespaceTable7);
 
 
 static const uc16 kWhitespaceTable16[] = {
   160, 8232, 8233, 5760, 6158, 8192, 8193, 8194, 8195,
   8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279
 };
-static const int kWhitespaceTable16Length = ARRAY_SIZE(kWhitespaceTable16);
+static const int kWhitespaceTable16Length = DOUBLE_CONVERSION_ARRAY_SIZE(kWhitespaceTable16);
 
 
 static bool isWhitespace(int x) {
@@ -590,7 +590,7 @@ static bool IsHexFloatString(Iterator start,
                              Iterator end,
                              uc16 separator,
                              bool allow_trailing_junk) {
-  ASSERT(start != end);
+  DOUBLE_CONVERSION_ASSERT(start != end);
 
   Iterator current = start;
 
@@ -635,8 +635,8 @@ static double RadixStringToIeee(Iterator* current,
                                 double junk_string_value,
                                 bool read_as_double,
                                 bool* result_is_junk) {
-  ASSERT(*current != end);
-  ASSERT(!parse_as_hex_float ||
+  DOUBLE_CONVERSION_ASSERT(*current != end);
+  DOUBLE_CONVERSION_ASSERT(!parse_as_hex_float ||
       IsHexFloatString(*current, end, separator, allow_trailing_junk));
 
   const int kDoubleSize = Double::kSignificandSize;
@@ -674,7 +674,7 @@ static double RadixStringToIeee(Iterator* current,
     } else if (parse_as_hex_float && **current == '.') {
       post_decimal = true;
       Advance(current, separator, radix, end);
-      ASSERT(*current != end);
+      DOUBLE_CONVERSION_ASSERT(*current != end);
       continue;
     } else if (parse_as_hex_float && (**current == 'p' || **current == 'P')) {
       break;
@@ -709,7 +709,7 @@ static double RadixStringToIeee(Iterator* current,
           // Just run over the '.'. We are just trying to see whether there is
           // a non-zero digit somewhere.
           Advance(current, separator, radix, end);
-          ASSERT(*current != end);
+          DOUBLE_CONVERSION_ASSERT(*current != end);
           post_decimal = true;
         }
         if (!isDigit(**current, radix)) break;
@@ -744,23 +744,23 @@ static double RadixStringToIeee(Iterator* current,
     if (Advance(current, separator, radix, end)) break;
   }
 
-  ASSERT(number < ((int64_t)1 << kSignificandSize));
-  ASSERT(static_cast<int64_t>(static_cast<double>(number)) == number);
+  DOUBLE_CONVERSION_ASSERT(number < ((int64_t)1 << kSignificandSize));
+  DOUBLE_CONVERSION_ASSERT(static_cast<int64_t>(static_cast<double>(number)) == number);
 
   *result_is_junk = false;
 
   if (parse_as_hex_float) {
-    ASSERT(**current == 'p' || **current == 'P');
+    DOUBLE_CONVERSION_ASSERT(**current == 'p' || **current == 'P');
     Advance(current, separator, radix, end);
-    ASSERT(*current != end);
+    DOUBLE_CONVERSION_ASSERT(*current != end);
     bool is_negative = false;
     if (**current == '+') {
       Advance(current, separator, radix, end);
-      ASSERT(*current != end);
+      DOUBLE_CONVERSION_ASSERT(*current != end);
     } else if (**current == '-') {
       is_negative = true;
       Advance(current, separator, radix, end);
-      ASSERT(*current != end);
+      DOUBLE_CONVERSION_ASSERT(*current != end);
     }
     int written_exponent = 0;
     while (IsDecimalDigitForRadix(**current, 10)) {
@@ -783,7 +783,7 @@ static double RadixStringToIeee(Iterator* current,
     return static_cast<double>(number);
   }
 
-  ASSERT(number != 0);
+  DOUBLE_CONVERSION_ASSERT(number != 0);
   double result = Double(DiyFp(number, exponent)).value();
   return sign ? -result : result;
 }
@@ -865,7 +865,7 @@ double StringToDoubleConverter::StringToIeee(
         return junk_string_value_;
       }
 
-      ASSERT(buffer_pos == 0);
+      DOUBLE_CONVERSION_ASSERT(buffer_pos == 0);
       *processed_characters_count = static_cast<int>(current - input);
       return sign ? -Double::Infinity() : Double::Infinity();
     }
@@ -884,7 +884,7 @@ double StringToDoubleConverter::StringToIeee(
         return junk_string_value_;
       }
 
-      ASSERT(buffer_pos == 0);
+      DOUBLE_CONVERSION_ASSERT(buffer_pos == 0);
       *processed_characters_count = static_cast<int>(current - input);
       return sign ? -Double::NaN() : Double::NaN();
     }
@@ -944,7 +944,7 @@ double StringToDoubleConverter::StringToIeee(
   // Copy significant digits of the integer part (if any) to the buffer.
   while (*current >= '0' && *current <= '9') {
     if (significant_digits < kMaxSignificantDigits) {
-      ASSERT(buffer_pos < kBufferSize);
+      DOUBLE_CONVERSION_ASSERT(buffer_pos < kBufferSize);
       buffer[buffer_pos++] = static_cast<char>(*current);
       significant_digits++;
       // Will later check if it's an octal in the buffer.
@@ -989,7 +989,7 @@ double StringToDoubleConverter::StringToIeee(
     // We don't emit a '.', but adjust the exponent instead.
     while (*current >= '0' && *current <= '9') {
       if (significant_digits < kMaxSignificantDigits) {
-        ASSERT(buffer_pos < kBufferSize);
+        DOUBLE_CONVERSION_ASSERT(buffer_pos < kBufferSize);
         buffer[buffer_pos++] = static_cast<char>(*current);
         significant_digits++;
         exponent--;
@@ -1047,7 +1047,7 @@ double StringToDoubleConverter::StringToIeee(
     }
 
     const int max_exponent = INT_MAX / 2;
-    ASSERT(-max_exponent / 2 <= exponent && exponent <= max_exponent / 2);
+    DOUBLE_CONVERSION_ASSERT(-max_exponent / 2 <= exponent && exponent <= max_exponent / 2);
     int num = 0;
     do {
       // Check overflow.
@@ -1090,7 +1090,7 @@ double StringToDoubleConverter::StringToIeee(
                                   junk_string_value_,
                                   read_as_double,
                                   &result_is_junk);
-    ASSERT(!result_is_junk);
+    DOUBLE_CONVERSION_ASSERT(!result_is_junk);
     *processed_characters_count = static_cast<int>(current - input);
     return result;
   }
@@ -1100,7 +1100,7 @@ double StringToDoubleConverter::StringToIeee(
     exponent--;
   }
 
-  ASSERT(buffer_pos < kBufferSize);
+  DOUBLE_CONVERSION_ASSERT(buffer_pos < kBufferSize);
   buffer[buffer_pos] = '\0';
 
   double converted;
diff --git a/double-conversion/double-conversion.h b/double-conversion/double-conversion.h
index 6dbc099..4fc24ed 100644
--- a/double-conversion/double-conversion.h
+++ b/double-conversion/double-conversion.h
@@ -124,7 +124,7 @@ class DoubleToStringConverter {
             max_trailing_padding_zeroes_in_precision_mode) {
     // When 'trailing zero after the point' is set, then 'trailing point'
     // must be set too.
-    ASSERT(((flags & EMIT_TRAILING_DECIMAL_POINT) != 0) ||
+    DOUBLE_CONVERSION_ASSERT(((flags & EMIT_TRAILING_DECIMAL_POINT) != 0) ||
         !((flags & EMIT_TRAILING_ZERO_AFTER_POINT) != 0));
   }
 
@@ -379,7 +379,7 @@ class DoubleToStringConverter {
   const int max_leading_padding_zeroes_in_precision_mode_;
   const int max_trailing_padding_zeroes_in_precision_mode_;
 
-  DC_DISALLOW_IMPLICIT_CONSTRUCTORS(DoubleToStringConverter);
+  DOUBLE_CONVERSION_DISALLOW_IMPLICIT_CONSTRUCTORS(DoubleToStringConverter);
 };
 
 
@@ -568,7 +568,7 @@ class StringToDoubleConverter {
                       bool read_as_double,
                       int* processed_characters_count) const;
 
-  DC_DISALLOW_IMPLICIT_CONSTRUCTORS(StringToDoubleConverter);
+  DOUBLE_CONVERSION_DISALLOW_IMPLICIT_CONSTRUCTORS(StringToDoubleConverter);
 };
 
 }  // namespace double_conversion
diff --git a/double-conversion/fast-dtoa.cc b/double-conversion/fast-dtoa.cc
index 6135038..f470286 100644
--- a/double-conversion/fast-dtoa.cc
+++ b/double-conversion/fast-dtoa.cc
@@ -138,7 +138,7 @@ static bool RoundWeed(Vector<char> buffer,
   // Conceptually rest ~= too_high - buffer
   // We need to do the following tests in this order to avoid over- and
   // underflows.
-  ASSERT(rest <= unsafe_interval);
+  DOUBLE_CONVERSION_ASSERT(rest <= unsafe_interval);
   while (rest < small_distance &&  // Negated condition 1
          unsafe_interval - rest >= ten_kappa &&  // Negated condition 2
          (rest + ten_kappa < small_distance ||  // buffer{-1} > w_high
@@ -184,7 +184,7 @@ static bool RoundWeedCounted(Vector<char> buffer,
                              uint64_t ten_kappa,
                              uint64_t unit,
                              int* kappa) {
-  ASSERT(rest < ten_kappa);
+  DOUBLE_CONVERSION_ASSERT(rest < ten_kappa);
   // The following tests are done in a specific order to avoid overflows. They
   // will work correctly with any uint64 values of rest < ten_kappa and unit.
   //
@@ -241,7 +241,7 @@ static void BiggestPowerTen(uint32_t number,
                             int number_bits,
                             uint32_t* power,
                             int* exponent_plus_one) {
-  ASSERT(number < (1u << (number_bits + 1)));
+  DOUBLE_CONVERSION_ASSERT(number < (1u << (number_bits + 1)));
   // 1233/4096 is approximately 1/lg(10).
   int exponent_plus_one_guess = ((number_bits + 1) * 1233 >> 12);
   // We increment to skip over the first entry in the kPowersOf10 table.
@@ -303,9 +303,9 @@ static bool DigitGen(DiyFp low,
                      Vector<char> buffer,
                      int* length,
                      int* kappa) {
-  ASSERT(low.e() == w.e() && w.e() == high.e());
-  ASSERT(low.f() + 1 <= high.f() - 1);
-  ASSERT(kMinimalTargetExponent <= w.e() && w.e() <= kMaximalTargetExponent);
+  DOUBLE_CONVERSION_ASSERT(low.e() == w.e() && w.e() == high.e());
+  DOUBLE_CONVERSION_ASSERT(low.f() + 1 <= high.f() - 1);
+  DOUBLE_CONVERSION_ASSERT(kMinimalTargetExponent <= w.e() && w.e() <= kMaximalTargetExponent);
   // low, w and high are imprecise, but by less than one ulp (unit in the last
   // place).
   // If we remove (resp. add) 1 ulp from low (resp. high) we are certain that
@@ -347,7 +347,7 @@ static bool DigitGen(DiyFp low,
   // that is smaller than integrals.
   while (*kappa > 0) {
     int digit = integrals / divisor;
-    ASSERT(digit <= 9);
+    DOUBLE_CONVERSION_ASSERT(digit <= 9);
     buffer[*length] = static_cast<char>('0' + digit);
     (*length)++;
     integrals %= divisor;
@@ -374,16 +374,16 @@ static bool DigitGen(DiyFp low,
   // data (like the interval or 'unit'), too.
   // Note that the multiplication by 10 does not overflow, because w.e >= -60
   // and thus one.e >= -60.
-  ASSERT(one.e() >= -60);
-  ASSERT(fractionals < one.f());
-  ASSERT(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF) / 10 >= one.f());
+  DOUBLE_CONVERSION_ASSERT(one.e() >= -60);
+  DOUBLE_CONVERSION_ASSERT(fractionals < one.f());
+  DOUBLE_CONVERSION_ASSERT(DOUBLE_CONVERSION_UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF) / 10 >= one.f());
   for (;;) {
     fractionals *= 10;
     unit *= 10;
     unsafe_interval.set_f(unsafe_interval.f() * 10);
     // Integer division by one.
     int digit = static_cast<int>(fractionals >> -one.e());
-    ASSERT(digit <= 9);
+    DOUBLE_CONVERSION_ASSERT(digit <= 9);
     buffer[*length] = static_cast<char>('0' + digit);
     (*length)++;
     fractionals &= one.f() - 1;  // Modulo by one.
@@ -430,9 +430,9 @@ static bool DigitGenCounted(DiyFp w,
                             Vector<char> buffer,
                             int* length,
                             int* kappa) {
-  ASSERT(kMinimalTargetExponent <= w.e() && w.e() <= kMaximalTargetExponent);
-  ASSERT(kMinimalTargetExponent >= -60);
-  ASSERT(kMaximalTargetExponent <= -32);
+  DOUBLE_CONVERSION_ASSERT(kMinimalTargetExponent <= w.e() && w.e() <= kMaximalTargetExponent);
+  DOUBLE_CONVERSION_ASSERT(kMinimalTargetExponent >= -60);
+  DOUBLE_CONVERSION_ASSERT(kMaximalTargetExponent <= -32);
   // w is assumed to have an error less than 1 unit. Whenever w is scaled we
   // also scale its error.
   uint64_t w_error = 1;
@@ -458,7 +458,7 @@ static bool DigitGenCounted(DiyFp w,
   // that is smaller than 'integrals'.
   while (*kappa > 0) {
     int digit = integrals / divisor;
-    ASSERT(digit <= 9);
+    DOUBLE_CONVERSION_ASSERT(digit <= 9);
     buffer[*length] = static_cast<char>('0' + digit);
     (*length)++;
     requested_digits--;
@@ -484,15 +484,15 @@ static bool DigitGenCounted(DiyFp w,
   // data (the 'unit'), too.
   // Note that the multiplication by 10 does not overflow, because w.e >= -60
   // and thus one.e >= -60.
-  ASSERT(one.e() >= -60);
-  ASSERT(fractionals < one.f());
-  ASSERT(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF) / 10 >= one.f());
+  DOUBLE_CONVERSION_ASSERT(one.e() >= -60);
+  DOUBLE_CONVERSION_ASSERT(fractionals < one.f());
+  DOUBLE_CONVERSION_ASSERT(DOUBLE_CONVERSION_UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF) / 10 >= one.f());
   while (requested_digits > 0 && fractionals > w_error) {
     fractionals *= 10;
     w_error *= 10;
     // Integer division by one.
     int digit = static_cast<int>(fractionals >> -one.e());
-    ASSERT(digit <= 9);
+    DOUBLE_CONVERSION_ASSERT(digit <= 9);
     buffer[*length] = static_cast<char>('0' + digit);
     (*length)++;
     requested_digits--;
@@ -530,11 +530,11 @@ static bool Grisu3(double v,
   if (mode == FAST_DTOA_SHORTEST) {
     Double(v).NormalizedBoundaries(&boundary_minus, &boundary_plus);
   } else {
-    ASSERT(mode == FAST_DTOA_SHORTEST_SINGLE);
+    DOUBLE_CONVERSION_ASSERT(mode == FAST_DTOA_SHORTEST_SINGLE);
     float single_v = static_cast<float>(v);
     Single(single_v).NormalizedBoundaries(&boundary_minus, &boundary_plus);
   }
-  ASSERT(boundary_plus.e() == w.e());
+  DOUBLE_CONVERSION_ASSERT(boundary_plus.e() == w.e());
   DiyFp ten_mk;  // Cached power of ten: 10^-k
   int mk;        // -k
   int ten_mk_minimal_binary_exponent =
@@ -545,7 +545,7 @@ static bool Grisu3(double v,
       ten_mk_minimal_binary_exponent,
       ten_mk_maximal_binary_exponent,
       &ten_mk, &mk);
-  ASSERT((kMinimalTargetExponent <= w.e() + ten_mk.e() +
+  DOUBLE_CONVERSION_ASSERT((kMinimalTargetExponent <= w.e() + ten_mk.e() +
           DiyFp::kSignificandSize) &&
          (kMaximalTargetExponent >= w.e() + ten_mk.e() +
           DiyFp::kSignificandSize));
@@ -559,7 +559,7 @@ static bool Grisu3(double v,
   // In other words: let f = scaled_w.f() and e = scaled_w.e(), then
   //           (f-1) * 2^e < w*10^k < (f+1) * 2^e
   DiyFp scaled_w = DiyFp::Times(w, ten_mk);
-  ASSERT(scaled_w.e() ==
+  DOUBLE_CONVERSION_ASSERT(scaled_w.e() ==
          boundary_plus.e() + ten_mk.e() + DiyFp::kSignificandSize);
   // In theory it would be possible to avoid some recomputations by computing
   // the difference between w and boundary_minus/plus (a power of 2) and to
@@ -604,7 +604,7 @@ static bool Grisu3Counted(double v,
       ten_mk_minimal_binary_exponent,
       ten_mk_maximal_binary_exponent,
       &ten_mk, &mk);
-  ASSERT((kMinimalTargetExponent <= w.e() + ten_mk.e() +
+  DOUBLE_CONVERSION_ASSERT((kMinimalTargetExponent <= w.e() + ten_mk.e() +
           DiyFp::kSignificandSize) &&
          (kMaximalTargetExponent >= w.e() + ten_mk.e() +
           DiyFp::kSignificandSize));
@@ -638,8 +638,8 @@ bool FastDtoa(double v,
               Vector<char> buffer,
               int* length,
               int* decimal_point) {
-  ASSERT(v > 0);
-  ASSERT(!Double(v).IsSpecial());
+  DOUBLE_CONVERSION_ASSERT(v > 0);
+  DOUBLE_CONVERSION_ASSERT(!Double(v).IsSpecial());
 
   bool result = false;
   int decimal_exponent = 0;
@@ -653,7 +653,7 @@ bool FastDtoa(double v,
                              buffer, length, &decimal_exponent);
       break;
     default:
-      UNREACHABLE();
+      DOUBLE_CONVERSION_UNREACHABLE();
   }
   if (result) {
     *decimal_point = *length + decimal_exponent;
diff --git a/double-conversion/fixed-dtoa.cc b/double-conversion/fixed-dtoa.cc
index 0f989bc..ab6ef10 100644
--- a/double-conversion/fixed-dtoa.cc
+++ b/double-conversion/fixed-dtoa.cc
@@ -53,11 +53,11 @@ class UInt128 {
     accumulator >>= 32;
     accumulator = accumulator + (high_bits_ >> 32) * multiplicand;
     high_bits_ = (accumulator << 32) + part;
-    ASSERT((accumulator >> 32) == 0);
+    DOUBLE_CONVERSION_ASSERT((accumulator >> 32) == 0);
   }
 
   void Shift(int shift_amount) {
-    ASSERT(-64 <= shift_amount && shift_amount <= 64);
+    DOUBLE_CONVERSION_ASSERT(-64 <= shift_amount && shift_amount <= 64);
     if (shift_amount == 0) {
       return;
     } else if (shift_amount == -64) {
@@ -230,13 +230,13 @@ static void RoundUp(Vector<char> buffer, int* length, int* decimal_point) {
 static void FillFractionals(uint64_t fractionals, int exponent,
                             int fractional_count, Vector<char> buffer,
                             int* length, int* decimal_point) {
-  ASSERT(-128 <= exponent && exponent <= 0);
+  DOUBLE_CONVERSION_ASSERT(-128 <= exponent && exponent <= 0);
   // 'fractionals' is a fixed-point number, with binary point at bit
   // (-exponent). Inside the function the non-converted remainder of fractionals
   // is a fixed-point number, with binary point at bit 'point'.
   if (-exponent <= 64) {
     // One 64 bit number is sufficient.
-    ASSERT(fractionals >> 56 == 0);
+    DOUBLE_CONVERSION_ASSERT(fractionals >> 56 == 0);
     int point = -exponent;
     for (int i = 0; i < fractional_count; ++i) {
       if (fractionals == 0) break;
@@ -253,18 +253,18 @@ static void FillFractionals(uint64_t fractionals, int exponent,
       fractionals *= 5;
       point--;
       int digit = static_cast<int>(fractionals >> point);
-      ASSERT(digit <= 9);
+      DOUBLE_CONVERSION_ASSERT(digit <= 9);
       buffer[*length] = static_cast<char>('0' + digit);
       (*length)++;
       fractionals -= static_cast<uint64_t>(digit) << point;
     }
     // If the first bit after the point is set we have to round up.
-    ASSERT(fractionals == 0 || point - 1 >= 0);
+    DOUBLE_CONVERSION_ASSERT(fractionals == 0 || point - 1 >= 0);
     if ((fractionals != 0) && ((fractionals >> (point - 1)) & 1) == 1) {
       RoundUp(buffer, length, decimal_point);
     }
   } else {  // We need 128 bits.
-    ASSERT(64 < -exponent && -exponent <= 128);
+    DOUBLE_CONVERSION_ASSERT(64 < -exponent && -exponent <= 128);
     UInt128 fractionals128 = UInt128(fractionals, 0);
     fractionals128.Shift(-exponent - 64);
     int point = 128;
@@ -276,7 +276,7 @@ static void FillFractionals(uint64_t fractionals, int exponent,
       fractionals128.Multiply(5);
       point--;
       int digit = fractionals128.DivModPowerOf2(point);
-      ASSERT(digit <= 9);
+      DOUBLE_CONVERSION_ASSERT(digit <= 9);
       buffer[*length] = static_cast<char>('0' + digit);
       (*length)++;
     }
@@ -335,7 +335,7 @@ bool FastFixedDtoa(double v,
     // The quotient delivers the first digits, and the remainder fits into a 64
     // bit number.
     // Dividing by 10^17 is equivalent to dividing by 5^17*2^17.
-    const uint64_t kFive17 = UINT64_2PART_C(0xB1, A2BC2EC5);  // 5^17
+    const uint64_t kFive17 = DOUBLE_CONVERSION_UINT64_2PART_C(0xB1, A2BC2EC5);  // 5^17
     uint64_t divisor = kFive17;
     int divisor_power = 17;
     uint64_t dividend = significand;
@@ -383,7 +383,7 @@ bool FastFixedDtoa(double v,
   } else if (exponent < -128) {
     // This configuration (with at most 20 digits) means that all digits must be
     // 0.
-    ASSERT(fractional_count <= 20);
+    DOUBLE_CONVERSION_ASSERT(fractional_count <= 20);
     buffer[0] = '\0';
     *length = 0;
     *decimal_point = -fractional_count;
diff --git a/double-conversion/ieee.h b/double-conversion/ieee.h
index 8327484..8c3b862 100644
--- a/double-conversion/ieee.h
+++ b/double-conversion/ieee.h
@@ -41,10 +41,10 @@ static float uint32_to_float(uint32_t d32) { return BitCast<float>(d32); }
 // Helper functions for doubles.
 class Double {
  public:
-  static const uint64_t kSignMask = UINT64_2PART_C(0x80000000, 00000000);
-  static const uint64_t kExponentMask = UINT64_2PART_C(0x7FF00000, 00000000);
-  static const uint64_t kSignificandMask = UINT64_2PART_C(0x000FFFFF, FFFFFFFF);
-  static const uint64_t kHiddenBit = UINT64_2PART_C(0x00100000, 00000000);
+  static const uint64_t kSignMask = DOUBLE_CONVERSION_UINT64_2PART_C(0x80000000, 00000000);
+  static const uint64_t kExponentMask = DOUBLE_CONVERSION_UINT64_2PART_C(0x7FF00000, 00000000);
+  static const uint64_t kSignificandMask = DOUBLE_CONVERSION_UINT64_2PART_C(0x000FFFFF, FFFFFFFF);
+  static const uint64_t kHiddenBit = DOUBLE_CONVERSION_UINT64_2PART_C(0x00100000, 00000000);
   static const int kPhysicalSignificandSize = 52;  // Excludes the hidden bit.
   static const int kSignificandSize = 53;
   static const int kExponentBias = 0x3FF + kPhysicalSignificandSize;
@@ -59,14 +59,14 @@ class Double {
   // The value encoded by this Double must be greater or equal to +0.0.
   // It must not be special (infinity, or NaN).
   DiyFp AsDiyFp() const {
-    ASSERT(Sign() > 0);
-    ASSERT(!IsSpecial());
+    DOUBLE_CONVERSION_ASSERT(Sign() > 0);
+    DOUBLE_CONVERSION_ASSERT(!IsSpecial());
     return DiyFp(Significand(), Exponent());
   }
 
   // The value encoded by this Double must be strictly greater than 0.
   DiyFp AsNormalizedDiyFp() const {
-    ASSERT(value() > 0.0);
+    DOUBLE_CONVERSION_ASSERT(value() > 0.0);
     uint64_t f = Significand();
     int e = Exponent();
 
@@ -162,7 +162,7 @@ class Double {
   // Precondition: the value encoded by this Double must be greater or equal
   // than +0.0.
   DiyFp UpperBoundary() const {
-    ASSERT(Sign() > 0);
+    DOUBLE_CONVERSION_ASSERT(Sign() > 0);
     return DiyFp(Significand() * 2 + 1, Exponent() - 1);
   }
 
@@ -171,7 +171,7 @@ class Double {
   // exponent as m_plus.
   // Precondition: the value encoded by this Double must be greater than 0.
   void NormalizedBoundaries(DiyFp* out_m_minus, DiyFp* out_m_plus) const {
-    ASSERT(value() > 0.0);
+    DOUBLE_CONVERSION_ASSERT(value() > 0.0);
     DiyFp v = this->AsDiyFp();
     DiyFp m_plus = DiyFp::Normalize(DiyFp((v.f() << 1) + 1, v.e() - 1));
     DiyFp m_minus;
@@ -225,8 +225,8 @@ class Double {
 
  private:
   static const int kDenormalExponent = -kExponentBias + 1;
-  static const uint64_t kInfinity = UINT64_2PART_C(0x7FF00000, 00000000);
-  static const uint64_t kNaN = UINT64_2PART_C(0x7FF80000, 00000000);
+  static const uint64_t kInfinity = DOUBLE_CONVERSION_UINT64_2PART_C(0x7FF00000, 00000000);
+  static const uint64_t kNaN = DOUBLE_CONVERSION_UINT64_2PART_C(0x7FF80000, 00000000);
 
   const uint64_t d64_;
 
@@ -257,7 +257,7 @@ class Double {
         (biased_exponent << kPhysicalSignificandSize);
   }
 
-  DC_DISALLOW_COPY_AND_ASSIGN(Double);
+  DOUBLE_CONVERSION_DISALLOW_COPY_AND_ASSIGN(Double);
 };
 
 class Single {
@@ -276,8 +276,8 @@ class Single {
   // The value encoded by this Single must be greater or equal to +0.0.
   // It must not be special (infinity, or NaN).
   DiyFp AsDiyFp() const {
-    ASSERT(Sign() > 0);
-    ASSERT(!IsSpecial());
+    DOUBLE_CONVERSION_ASSERT(Sign() > 0);
+    DOUBLE_CONVERSION_ASSERT(!IsSpecial());
     return DiyFp(Significand(), Exponent());
   }
 
@@ -340,7 +340,7 @@ class Single {
   // exponent as m_plus.
   // Precondition: the value encoded by this Single must be greater than 0.
   void NormalizedBoundaries(DiyFp* out_m_minus, DiyFp* out_m_plus) const {
-    ASSERT(value() > 0.0);
+    DOUBLE_CONVERSION_ASSERT(value() > 0.0);
     DiyFp v = this->AsDiyFp();
     DiyFp m_plus = DiyFp::Normalize(DiyFp((v.f() << 1) + 1, v.e() - 1));
     DiyFp m_minus;
@@ -358,7 +358,7 @@ class Single {
   // Precondition: the value encoded by this Single must be greater or equal
   // than +0.0.
   DiyFp UpperBoundary() const {
-    ASSERT(Sign() > 0);
+    DOUBLE_CONVERSION_ASSERT(Sign() > 0);
     return DiyFp(Significand() * 2 + 1, Exponent() - 1);
   }
 
@@ -394,7 +394,7 @@ class Single {
 
   const uint32_t d32_;
 
-  DC_DISALLOW_COPY_AND_ASSIGN(Single);
+  DOUBLE_CONVERSION_DISALLOW_COPY_AND_ASSIGN(Single);
 };
 
 }  // namespace double_conversion
diff --git a/double-conversion/strtod.cc b/double-conversion/strtod.cc
index a75cf5d..7feb374 100644
--- a/double-conversion/strtod.cc
+++ b/double-conversion/strtod.cc
@@ -52,7 +52,7 @@ static const int kMaxDecimalPower = 309;
 static const int kMinDecimalPower = -324;
 
 // 2^64 = 18446744073709551616
-static const uint64_t kMaxUint64 = UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF);
+static const uint64_t kMaxUint64 = DOUBLE_CONVERSION_UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF);
 
 
 static const double exact_powers_of_ten[] = {
@@ -81,7 +81,7 @@ static const double exact_powers_of_ten[] = {
   // 10^22 = 0x21e19e0c9bab2400000 = 0x878678326eac9 * 2^22
   10000000000000000000000.0
 };
-static const int kExactPowersOfTenSize = ARRAY_SIZE(exact_powers_of_ten);
+static const int kExactPowersOfTenSize = DOUBLE_CONVERSION_ARRAY_SIZE(exact_powers_of_ten);
 
 // Maximum number of significant digits in the decimal representation.
 // In fact the value is 772 (see conversions.cc), but to give us some margin
@@ -117,7 +117,7 @@ static void CutToMaxSignificantDigits(Vector<const char> buffer,
   }
   // The input buffer has been trimmed. Therefore the last digit must be
   // different from '0'.
-  ASSERT(buffer[buffer.length() - 1] != '0');
+  DOUBLE_CONVERSION_ASSERT(buffer[buffer.length() - 1] != '0');
   // Set the last digit to be non-zero. This is sufficient to guarantee
   // correct rounding.
   significant_buffer[kMaxSignificantDecimalDigits - 1] = '1';
@@ -138,7 +138,7 @@ static void TrimAndCut(Vector<const char> buffer, int exponent,
   exponent += left_trimmed.length() - right_trimmed.length();
   if (right_trimmed.length() > kMaxSignificantDecimalDigits) {
     (void) space_size;  // Mark variable as used.
-    ASSERT(space_size >= kMaxSignificantDecimalDigits);
+    DOUBLE_CONVERSION_ASSERT(space_size >= kMaxSignificantDecimalDigits);
     CutToMaxSignificantDigits(right_trimmed, exponent,
                               buffer_copy_space, updated_exponent);
     *trimmed = Vector<const char>(buffer_copy_space,
@@ -161,7 +161,7 @@ static uint64_t ReadUint64(Vector<const char> buffer,
   int i = 0;
   while (i < buffer.length() && result <= (kMaxUint64 / 10 - 1)) {
     int digit = buffer[i++] - '0';
-    ASSERT(0 <= digit && digit <= 9);
+    DOUBLE_CONVERSION_ASSERT(0 <= digit && digit <= 9);
     result = 10 * result + digit;
   }
   *number_of_read_digits = i;
@@ -217,14 +217,14 @@ static bool DoubleStrtod(Vector<const char> trimmed,
     if (exponent < 0 && -exponent < kExactPowersOfTenSize) {
       // 10^-exponent fits into a double.
       *result = static_cast<double>(ReadUint64(trimmed, &read_digits));
-      ASSERT(read_digits == trimmed.length());
+      DOUBLE_CONVERSION_ASSERT(read_digits == trimmed.length());
       *result /= exact_powers_of_ten[-exponent];
       return true;
     }
     if (0 <= exponent && exponent < kExactPowersOfTenSize) {
       // 10^exponent fits into a double.
       *result = static_cast<double>(ReadUint64(trimmed, &read_digits));
-      ASSERT(read_digits == trimmed.length());
+      DOUBLE_CONVERSION_ASSERT(read_digits == trimmed.length());
       *result *= exact_powers_of_ten[exponent];
       return true;
     }
@@ -236,7 +236,7 @@ static bool DoubleStrtod(Vector<const char> trimmed,
       // 10^remaining_digits. As a result the remaining exponent now fits
       // into a double too.
       *result = static_cast<double>(ReadUint64(trimmed, &read_digits));
-      ASSERT(read_digits == trimmed.length());
+      DOUBLE_CONVERSION_ASSERT(read_digits == trimmed.length());
       *result *= exact_powers_of_ten[remaining_digits];
       *result *= exact_powers_of_ten[exponent - remaining_digits];
       return true;
@@ -250,21 +250,21 @@ static bool DoubleStrtod(Vector<const char> trimmed,
 // Returns 10^exponent as an exact DiyFp.
 // The given exponent must be in the range [1; kDecimalExponentDistance[.
 static DiyFp AdjustmentPowerOfTen(int exponent) {
-  ASSERT(0 < exponent);
-  ASSERT(exponent < PowersOfTenCache::kDecimalExponentDistance);
+  DOUBLE_CONVERSION_ASSERT(0 < exponent);
+  DOUBLE_CONVERSION_ASSERT(exponent < PowersOfTenCache::kDecimalExponentDistance);
   // Simply hardcode the remaining powers for the given decimal exponent
   // distance.
-  ASSERT(PowersOfTenCache::kDecimalExponentDistance == 8);
+  DOUBLE_CONVERSION_ASSERT(PowersOfTenCache::kDecimalExponentDistance == 8);
   switch (exponent) {
-    case 1: return DiyFp(UINT64_2PART_C(0xa0000000, 00000000), -60);
-    case 2: return DiyFp(UINT64_2PART_C(0xc8000000, 00000000), -57);
-    case 3: return DiyFp(UINT64_2PART_C(0xfa000000, 00000000), -54);
-    case 4: return DiyFp(UINT64_2PART_C(0x9c400000, 00000000), -50);
-    case 5: return DiyFp(UINT64_2PART_C(0xc3500000, 00000000), -47);
-    case 6: return DiyFp(UINT64_2PART_C(0xf4240000, 00000000), -44);
-    case 7: return DiyFp(UINT64_2PART_C(0x98968000, 00000000), -40);
+    case 1: return DiyFp(DOUBLE_CONVERSION_UINT64_2PART_C(0xa0000000, 00000000), -60);
+    case 2: return DiyFp(DOUBLE_CONVERSION_UINT64_2PART_C(0xc8000000, 00000000), -57);
+    case 3: return DiyFp(DOUBLE_CONVERSION_UINT64_2PART_C(0xfa000000, 00000000), -54);
+    case 4: return DiyFp(DOUBLE_CONVERSION_UINT64_2PART_C(0x9c400000, 00000000), -50);
+    case 5: return DiyFp(DOUBLE_CONVERSION_UINT64_2PART_C(0xc3500000, 00000000), -47);
+    case 6: return DiyFp(DOUBLE_CONVERSION_UINT64_2PART_C(0xf4240000, 00000000), -44);
+    case 7: return DiyFp(DOUBLE_CONVERSION_UINT64_2PART_C(0x98968000, 00000000), -40);
     default:
-      UNREACHABLE();
+      DOUBLE_CONVERSION_UNREACHABLE();
   }
 }
 
@@ -293,7 +293,7 @@ static bool DiyFpStrtod(Vector<const char> buffer,
   input.Normalize();
   error <<= old_e - input.e();
 
-  ASSERT(exponent <= PowersOfTenCache::kMaxDecimalExponent);
+  DOUBLE_CONVERSION_ASSERT(exponent <= PowersOfTenCache::kMaxDecimalExponent);
   if (exponent < PowersOfTenCache::kMinDecimalExponent) {
     *result = 0.0;
     return true;
@@ -311,7 +311,7 @@ static bool DiyFpStrtod(Vector<const char> buffer,
     if (kMaxUint64DecimalDigits - buffer.length() >= adjustment_exponent) {
       // The product of input with the adjustment power fits into a 64 bit
       // integer.
-      ASSERT(DiyFp::kSignificandSize == 64);
+      DOUBLE_CONVERSION_ASSERT(DiyFp::kSignificandSize == 64);
     } else {
       // The adjustment power is exact. There is hence only an error of 0.5.
       error += kDenominator / 2;
@@ -353,8 +353,8 @@ static bool DiyFpStrtod(Vector<const char> buffer,
     precision_digits_count -= shift_amount;
   }
   // We use uint64_ts now. This only works if the DiyFp uses uint64_ts too.
-  ASSERT(DiyFp::kSignificandSize == 64);
-  ASSERT(precision_digits_count < 64);
+  DOUBLE_CONVERSION_ASSERT(DiyFp::kSignificandSize == 64);
+  DOUBLE_CONVERSION_ASSERT(precision_digits_count < 64);
   uint64_t one64 = 1;
   uint64_t precision_bits_mask = (one64 << precision_digits_count) - 1;
   uint64_t precision_bits = input.f() & precision_bits_mask;
@@ -393,14 +393,14 @@ static bool DiyFpStrtod(Vector<const char> buffer,
 static int CompareBufferWithDiyFp(Vector<const char> buffer,
                                   int exponent,
                                   DiyFp diy_fp) {
-  ASSERT(buffer.length() + exponent <= kMaxDecimalPower + 1);
-  ASSERT(buffer.length() + exponent > kMinDecimalPower);
-  ASSERT(buffer.length() <= kMaxSignificantDecimalDigits);
+  DOUBLE_CONVERSION_ASSERT(buffer.length() + exponent <= kMaxDecimalPower + 1);
+  DOUBLE_CONVERSION_ASSERT(buffer.length() + exponent > kMinDecimalPower);
+  DOUBLE_CONVERSION_ASSERT(buffer.length() <= kMaxSignificantDecimalDigits);
   // Make sure that the Bignum will be able to hold all our numbers.
   // Our Bignum implementation has a separate field for exponents. Shifts will
   // consume at most one bigit (< 64 bits).
   // ln(10) == 3.3219...
-  ASSERT(((kMaxDecimalPower + 1) * 333 / 100) < Bignum::kMaxSignificantBits);
+  DOUBLE_CONVERSION_ASSERT(((kMaxDecimalPower + 1) * 333 / 100) < Bignum::kMaxSignificantBits);
   Bignum buffer_bignum;
   Bignum diy_fp_bignum;
   buffer_bignum.AssignDecimalString(buffer);
@@ -473,7 +473,7 @@ double Strtod(Vector<const char> buffer, int exponent) {
 }
 
 static float SanitizedDoubletof(double d) {
-  ASSERT(d >= 0.0);
+  DOUBLE_CONVERSION_ASSERT(d >= 0.0);
   // ASAN has a sanitize check that disallows casting doubles to floats if
   // they are too big.
   // https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#available-checks
@@ -541,7 +541,7 @@ float Strtof(Vector<const char> buffer, int exponent) {
     f4 = SanitizedDoubletof(double_next2);
   }
   (void) f2;  // Mark variable as used.
-  ASSERT(f1 <= f2 && f2 <= f3 && f3 <= f4);
+  DOUBLE_CONVERSION_ASSERT(f1 <= f2 && f2 <= f3 && f3 <= f4);
 
   // If the guess doesn't lie near a single-precision boundary we can simply
   // return its float-value.
@@ -549,7 +549,7 @@ float Strtof(Vector<const char> buffer, int exponent) {
     return float_guess;
   }
 
-  ASSERT((f1 != f2 && f2 == f3 && f3 == f4) ||
+  DOUBLE_CONVERSION_ASSERT((f1 != f2 && f2 == f3 && f3 == f4) ||
          (f1 == f2 && f2 != f3 && f3 == f4) ||
          (f1 == f2 && f2 == f3 && f3 != f4));
 
diff --git a/double-conversion/utils.h b/double-conversion/utils.h
index 0122354..3a4d587 100644
--- a/double-conversion/utils.h
+++ b/double-conversion/utils.h
@@ -32,12 +32,12 @@
 #include <cstring>
 
 #include <cassert>
-#ifndef ASSERT
-#define ASSERT(condition)         \
+#ifndef DOUBLE_CONVERSION_ASSERT
+#define DOUBLE_CONVERSION_ASSERT(condition)         \
     assert(condition);
 #endif
-#ifndef UNIMPLEMENTED
-#define UNIMPLEMENTED() (abort())
+#ifndef DOUBLE_CONVERSION_UNIMPLEMENTED
+#define DOUBLE_CONVERSION_UNIMPLEMENTED() (abort())
 #endif
 #ifndef DOUBLE_CONVERSION_NO_RETURN
 #ifdef _MSC_VER
@@ -46,13 +46,13 @@
 #define DOUBLE_CONVERSION_NO_RETURN __attribute__((noreturn))
 #endif
 #endif
-#ifndef UNREACHABLE
+#ifndef DOUBLE_CONVERSION_UNREACHABLE
 #ifdef _MSC_VER
 void DOUBLE_CONVERSION_NO_RETURN abort_noreturn();
 inline void abort_noreturn() { abort(); }
-#define UNREACHABLE()   (abort_noreturn())
+#define DOUBLE_CONVERSION_UNREACHABLE()   (abort_noreturn())
 #else
-#define UNREACHABLE()   (abort())
+#define DOUBLE_CONVERSION_UNREACHABLE()   (abort())
 #endif
 #endif
 
@@ -140,24 +140,24 @@ typedef uint16_t uc16;
 
 // The following macro works on both 32 and 64-bit platforms.
 // Usage: instead of writing 0x1234567890123456
-//      write UINT64_2PART_C(0x12345678,90123456);
-#define UINT64_2PART_C(a, b) (((static_cast<uint64_t>(a) << 32) + 0x##b##u))
+//      write DOUBLE_CONVERSION_UINT64_2PART_C(0x12345678,90123456);
+#define DOUBLE_CONVERSION_UINT64_2PART_C(a, b) (((static_cast<uint64_t>(a) << 32) + 0x##b##u))
 
 
-// The expression ARRAY_SIZE(a) is a compile-time constant of type
+// The expression DOUBLE_CONVERSION_ARRAY_SIZE(a) is a compile-time constant of type
 // size_t which represents the number of elements of the given
-// array. You should only use ARRAY_SIZE on statically allocated
+// array. You should only use DOUBLE_CONVERSION_ARRAY_SIZE on statically allocated
 // arrays.
-#ifndef ARRAY_SIZE
-#define ARRAY_SIZE(a)                                   \
+#ifndef DOUBLE_CONVERSION_ARRAY_SIZE
+#define DOUBLE_CONVERSION_ARRAY_SIZE(a)                                   \
   ((sizeof(a) / sizeof(*(a))) /                         \
   static_cast<size_t>(!(sizeof(a) % sizeof(*(a)))))
 #endif
 
 // A macro to disallow the evil copy constructor and operator= functions
 // This should be used in the private: declarations for a class
-#ifndef DC_DISALLOW_COPY_AND_ASSIGN
-#define DC_DISALLOW_COPY_AND_ASSIGN(TypeName)      \
+#ifndef DOUBLE_CONVERSION_DISALLOW_COPY_AND_ASSIGN
+#define DOUBLE_CONVERSION_DISALLOW_COPY_AND_ASSIGN(TypeName)      \
   TypeName(const TypeName&);                    \
   void operator=(const TypeName&)
 #endif
@@ -168,10 +168,10 @@ typedef uint16_t uc16;
 // This should be used in the private: declarations for a class
 // that wants to prevent anyone from instantiating it. This is
 // especially useful for classes containing only static methods.
-#ifndef DC_DISALLOW_IMPLICIT_CONSTRUCTORS
-#define DC_DISALLOW_IMPLICIT_CONSTRUCTORS(TypeName) \
+#ifndef DOUBLE_CONVERSION_DISALLOW_IMPLICIT_CONSTRUCTORS
+#define DOUBLE_CONVERSION_DISALLOW_IMPLICIT_CONSTRUCTORS(TypeName) \
   TypeName();                                    \
-  DC_DISALLOW_COPY_AND_ASSIGN(TypeName)
+  DOUBLE_CONVERSION_DISALLOW_COPY_AND_ASSIGN(TypeName)
 #endif
 
 namespace double_conversion {
@@ -180,7 +180,7 @@ static const int kCharSize = sizeof(char);
 
 inline int StrLength(const char* string) {
   size_t length = strlen(string);
-  ASSERT(length == static_cast<size_t>(static_cast<int>(length)));
+  DOUBLE_CONVERSION_ASSERT(length == static_cast<size_t>(static_cast<int>(length)));
   return static_cast<int>(length);
 }
 
@@ -190,15 +190,15 @@ class Vector {
  public:
   Vector() : start_(NULL), length_(0) {}
   Vector(T* data, int len) : start_(data), length_(len) {
-    ASSERT(len == 0 || (len > 0 && data != NULL));
+    DOUBLE_CONVERSION_ASSERT(len == 0 || (len > 0 && data != NULL));
   }
 
   // Returns a vector using the same backing storage as this one,
   // spanning from and including 'from', to but not including 'to'.
   Vector<T> SubVector(int from, int to) {
-    ASSERT(to <= length_);
-    ASSERT(from < to);
-    ASSERT(0 <= from);
+    DOUBLE_CONVERSION_ASSERT(to <= length_);
+    DOUBLE_CONVERSION_ASSERT(from < to);
+    DOUBLE_CONVERSION_ASSERT(0 <= from);
     return Vector<T>(start() + from, to - from);
   }
 
@@ -213,7 +213,7 @@ class Vector {
 
   // Access individual vector elements - checks bounds in debug mode.
   T& operator[](int index) const {
-    ASSERT(0 <= index && index < length_);
+    DOUBLE_CONVERSION_ASSERT(0 <= index && index < length_);
     return start_[index];
   }
 
@@ -241,7 +241,7 @@ class StringBuilder {
 
   // Get the current position in the builder.
   int position() const {
-    ASSERT(!is_finalized());
+    DOUBLE_CONVERSION_ASSERT(!is_finalized());
     return position_;
   }
 
@@ -252,8 +252,8 @@ class StringBuilder {
   // 0-characters; use the Finalize() method to terminate the string
   // instead.
   void AddCharacter(char c) {
-    ASSERT(c != '\0');
-    ASSERT(!is_finalized() && position_ < buffer_.length());
+    DOUBLE_CONVERSION_ASSERT(c != '\0');
+    DOUBLE_CONVERSION_ASSERT(!is_finalized() && position_ < buffer_.length());
     buffer_[position_++] = c;
   }
 
@@ -266,8 +266,8 @@ class StringBuilder {
   // Add the first 'n' characters of the given string 's' to the
   // builder. The input string must have enough characters.
   void AddSubstring(const char* s, int n) {
-    ASSERT(!is_finalized() && position_ + n < buffer_.length());
-    ASSERT(static_cast<size_t>(n) <= strlen(s));
+    DOUBLE_CONVERSION_ASSERT(!is_finalized() && position_ + n < buffer_.length());
+    DOUBLE_CONVERSION_ASSERT(static_cast<size_t>(n) <= strlen(s));
     memmove(&buffer_[position_], s, n * kCharSize);
     position_ += n;
   }
@@ -283,13 +283,13 @@ class StringBuilder {
 
   // Finalize the string by 0-terminating it and returning the buffer.
   char* Finalize() {
-    ASSERT(!is_finalized() && position_ < buffer_.length());
+    DOUBLE_CONVERSION_ASSERT(!is_finalized() && position_ < buffer_.length());
     buffer_[position_] = '\0';
     // Make sure nobody managed to add a 0-character to the
     // buffer while building the string.
-    ASSERT(strlen(buffer_.start()) == static_cast<size_t>(position_));
+    DOUBLE_CONVERSION_ASSERT(strlen(buffer_.start()) == static_cast<size_t>(position_));
     position_ = -1;
-    ASSERT(is_finalized());
+    DOUBLE_CONVERSION_ASSERT(is_finalized());
     return buffer_.start();
   }
 
@@ -299,7 +299,7 @@ class StringBuilder {
 
   bool is_finalized() const { return position_ < 0; }
 
-  DC_DISALLOW_IMPLICIT_CONSTRUCTORS(StringBuilder);
+  DOUBLE_CONVERSION_DISALLOW_IMPLICIT_CONSTRUCTORS(StringBuilder);
 };
 
 // The type-based aliasing rule allows the compiler to assume that pointers of
diff --git a/test/cctest/checks.h b/test/cctest/checks.h
index 5ea5992..4b0a703 100644
--- a/test/cctest/checks.h
+++ b/test/cctest/checks.h
@@ -35,21 +35,21 @@
 extern "C" void V8_Fatal(const char* file, int line, const char* format, ...);
 void API_Fatal(const char* location, const char* format, ...);
 
-// The FATAL, UNREACHABLE and UNIMPLEMENTED macros are useful during
+// The FATAL, DOUBLE_CONVERSION_UNREACHABLE and DOUBLE_CONVERSION_UNIMPLEMENTED macros are useful during
 // development, but they should not be relied on in the final product.
 #ifdef DEBUG
 #define FATAL(msg)                              \
   V8_Fatal(__FILE__, __LINE__, "%s", (msg))
-#define UNIMPLEMENTED()                         \
+#define DOUBLE_CONVERSION_UNIMPLEMENTED()                         \
   V8_Fatal(__FILE__, __LINE__, "unimplemented code")
-#define UNREACHABLE()                           \
+#define DOUBLE_CONVERSION_UNREACHABLE()                           \
   V8_Fatal(__FILE__, __LINE__, "unreachable code")
 #else
 #define FATAL(msg)                              \
   V8_Fatal("", 0, "%s", (msg))
-#define UNIMPLEMENTED()                         \
+#define DOUBLE_CONVERSION_UNIMPLEMENTED()                         \
   V8_Fatal("", 0, "unimplemented code")
-#define UNREACHABLE() ((void) 0)
+#define DOUBLE_CONVERSION_UNREACHABLE() ((void) 0)
 #endif
 
 
@@ -279,36 +279,36 @@ template <int> class StaticAssertionHelper { };
     SEMI_STATIC_JOIN(__StaticAssertTypedef__, __LINE__)
 
 
-// The ASSERT macro is equivalent to CHECK except that it only
+// The DOUBLE_CONVERSION_ASSERT macro is equivalent to CHECK except that it only
 // generates code in debug builds.
 #ifdef DEBUG
-#define ASSERT_RESULT(expr)  CHECK(expr)
-#define ASSERT(condition)    CHECK(condition)
-#define ASSERT_EQ(v1, v2)    CHECK_EQ(v1, v2)
-#define ASSERT_NE(v1, v2)    CHECK_NE(v1, v2)
-#define ASSERT_GE(v1, v2)    CHECK_GE(v1, v2)
-#define SLOW_ASSERT(condition) if (FLAG_enable_slow_asserts) CHECK(condition)
+#define DOUBLE_CONVERSION_ASSERT_RESULT(expr)  CHECK(expr)
+#define DOUBLE_CONVERSION_ASSERT(condition)    CHECK(condition)
+#define DOUBLE_CONVERSION_ASSERT_EQ(v1, v2)    CHECK_EQ(v1, v2)
+#define DOUBLE_CONVERSION_ASSERT_NE(v1, v2)    CHECK_NE(v1, v2)
+#define DOUBLE_CONVERSION_ASSERT_GE(v1, v2)    CHECK_GE(v1, v2)
+#define SLOW_DOUBLE_CONVERSION_ASSERT(condition) if (FLAG_enable_slow_asserts) CHECK(condition)
 #else
-#define ASSERT_RESULT(expr)     (expr)
-#define ASSERT(condition)      ((void) 0)
-#define ASSERT_EQ(v1, v2)      ((void) 0)
-#define ASSERT_NE(v1, v2)      ((void) 0)
-#define ASSERT_GE(v1, v2)      ((void) 0)
-#define SLOW_ASSERT(condition) ((void) 0)
+#define DOUBLE_CONVERSION_ASSERT_RESULT(expr)     (expr)
+#define DOUBLE_CONVERSION_ASSERT(condition)      ((void) 0)
+#define DOUBLE_CONVERSION_ASSERT_EQ(v1, v2)      ((void) 0)
+#define DOUBLE_CONVERSION_ASSERT_NE(v1, v2)      ((void) 0)
+#define DOUBLE_CONVERSION_ASSERT_GE(v1, v2)      ((void) 0)
+#define SLOW_DOUBLE_CONVERSION_ASSERT(condition) ((void) 0)
 #endif
 // Static asserts has no impact on runtime performance, so they can be
 // safely enabled in release mode. Moreover, the ((void) 0) expression
 // obeys different syntax rules than typedef's, e.g. it can't appear
 // inside class declaration, this leads to inconsistency between debug
 // and release compilation modes behaviour.
-#define STATIC_ASSERT(test)  STATIC_CHECK(test)
+#define STATIC_DOUBLE_CONVERSION_ASSERT(test)  STATIC_CHECK(test)
 
 
-#define ASSERT_TAG_ALIGNED(address) \
-  ASSERT((reinterpret_cast<intptr_t>(address) & kHeapObjectTagMask) == 0)
+#define DOUBLE_CONVERSION_ASSERT_TAG_ALIGNED(address) \
+  DOUBLE_CONVERSION_ASSERT((reinterpret_cast<intptr_t>(address) & kHeapObjectTagMask) == 0)
 
-#define ASSERT_SIZE_TAG_ALIGNED(size) ASSERT((size & kHeapObjectTagMask) == 0)
+#define DOUBLE_CONVERSION_ASSERT_SIZE_TAG_ALIGNED(size) DOUBLE_CONVERSION_ASSERT((size & kHeapObjectTagMask) == 0)
 
-#define ASSERT_NOT_NULL(p)  ASSERT_NE(NULL, p)
+#define DOUBLE_CONVERSION_ASSERT_NOT_NULL(p)  DOUBLE_CONVERSION_ASSERT_NE(NULL, p)
 
 #endif  // V8_CHECKS_H_
diff --git a/test/cctest/test-bignum-dtoa.cc b/test/cctest/test-bignum-dtoa.cc
index 28063a5..e2367d9 100644
--- a/test/cctest/test-bignum-dtoa.cc
+++ b/test/cctest/test-bignum-dtoa.cc
@@ -196,7 +196,7 @@ TEST(BignumDtoaVariousDoubles) {
   CHECK_EQ("1", buffer.start());
   CHECK_EQ(-22, point);
 
-  uint64_t smallest_normal64 = UINT64_2PART_C(0x00100000, 00000000);
+  uint64_t smallest_normal64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x00100000, 00000000);
   double v = Double(smallest_normal64).value();
   BignumDtoa(v, BIGNUM_DTOA_SHORTEST, 0, buffer, &length, &point);
   CHECK_EQ("22250738585072014", buffer.start());
@@ -208,7 +208,7 @@ TEST(BignumDtoaVariousDoubles) {
   CHECK_EQ("22250738585072013831", buffer.start());
   CHECK_EQ(-307, point);
 
-  uint64_t largest_denormal64 = UINT64_2PART_C(0x000FFFFF, FFFFFFFF);
+  uint64_t largest_denormal64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x000FFFFF, FFFFFFFF);
   v = Double(largest_denormal64).value();
   BignumDtoa(v, BIGNUM_DTOA_SHORTEST, 0, buffer, &length, &point);
   CHECK_EQ("2225073858507201", buffer.start());
diff --git a/test/cctest/test-bignum.cc b/test/cctest/test-bignum.cc
index 84c4a09..0653b27 100644
--- a/test/cctest/test-bignum.cc
+++ b/test/cctest/test-bignum.cc
@@ -81,12 +81,12 @@ TEST(Assign) {
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("12345678", buffer);
 
-  uint64_t big = UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF);
+  uint64_t big = DOUBLE_CONVERSION_UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF);
   bignum.AssignUInt64(big);
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("FFFFFFFFFFFFFFFF", buffer);
 
-  big = UINT64_2PART_C(0x12345678, 9ABCDEF0);
+  big = DOUBLE_CONVERSION_UINT64_2PART_C(0x12345678, 9ABCDEF0);
   bignum.AssignUInt64(big);
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("123456789ABCDEF0", buffer);
@@ -206,49 +206,49 @@ TEST(AddUInt64) {
   CHECK_EQ("1000000000000000000000FFFF", buffer);
 
   AssignHexString(&bignum, "0");
-  bignum.AddUInt64(UINT64_2PART_C(0xA, 00000000));
+  bignum.AddUInt64(DOUBLE_CONVERSION_UINT64_2PART_C(0xA, 00000000));
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("A00000000", buffer);
 
   AssignHexString(&bignum, "1");
-  bignum.AddUInt64(UINT64_2PART_C(0xA, 00000000));
+  bignum.AddUInt64(DOUBLE_CONVERSION_UINT64_2PART_C(0xA, 00000000));
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("A00000001", buffer);
 
   AssignHexString(&bignum, "1");
-  bignum.AddUInt64(UINT64_2PART_C(0x100, 00000000));
+  bignum.AddUInt64(DOUBLE_CONVERSION_UINT64_2PART_C(0x100, 00000000));
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("10000000001", buffer);
 
   AssignHexString(&bignum, "1");
-  bignum.AddUInt64(UINT64_2PART_C(0xFFFF, 00000000));
+  bignum.AddUInt64(DOUBLE_CONVERSION_UINT64_2PART_C(0xFFFF, 00000000));
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("FFFF00000001", buffer);
 
   AssignHexString(&bignum, "FFFFFFF");
-  bignum.AddUInt64(UINT64_2PART_C(0x1, 00000000));
+  bignum.AddUInt64(DOUBLE_CONVERSION_UINT64_2PART_C(0x1, 00000000));
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("10FFFFFFF", buffer);
 
   AssignHexString(&bignum, "10000000000000000000000000000000000000000000");
-  bignum.AddUInt64(UINT64_2PART_C(0xFFFF, 00000000));
+  bignum.AddUInt64(DOUBLE_CONVERSION_UINT64_2PART_C(0xFFFF, 00000000));
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("10000000000000000000000000000000FFFF00000000", buffer);
 
   AssignHexString(&bignum, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");
-  bignum.AddUInt64(UINT64_2PART_C(0x1, 00000000));
+  bignum.AddUInt64(DOUBLE_CONVERSION_UINT64_2PART_C(0x1, 00000000));
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("1000000000000000000000000000000000000FFFFFFFF", buffer);
 
   bignum.AssignUInt16(0x1);
   bignum.ShiftLeft(100);
-  bignum.AddUInt64(UINT64_2PART_C(0x1, 00000000));
+  bignum.AddUInt64(DOUBLE_CONVERSION_UINT64_2PART_C(0x1, 00000000));
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("10000000000000000100000000", buffer);
 
   bignum.AssignUInt16(0x1);
   bignum.ShiftLeft(100);
-  bignum.AddUInt64(UINT64_2PART_C(0xFFFF, 00000000));
+  bignum.AddUInt64(DOUBLE_CONVERSION_UINT64_2PART_C(0xFFFF, 00000000));
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("10000000000000FFFF00000000", buffer);
 }
@@ -570,7 +570,7 @@ TEST(MultiplyUInt64) {
   CHECK_EQ("FFFF00000000000000", buffer);
 
   AssignHexString(&bignum, "100000000000000");
-  bignum.MultiplyByUInt64(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF));
+  bignum.MultiplyByUInt64(DOUBLE_CONVERSION_UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF));
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("FFFFFFFFFFFFFFFF00000000000000", buffer);
 
@@ -580,7 +580,7 @@ TEST(MultiplyUInt64) {
   CHECK_EQ("12333335552433", buffer);
 
   AssignHexString(&bignum, "1234567ABCD");
-  bignum.MultiplyByUInt64(UINT64_2PART_C(0xFF, FFFFFFFF));
+  bignum.MultiplyByUInt64(DOUBLE_CONVERSION_UINT64_2PART_C(0xFF, FFFFFFFF));
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("1234567ABCBDCBA985433", buffer);
 
@@ -600,7 +600,7 @@ TEST(MultiplyUInt64) {
   CHECK_EQ("EFFFFFFFFFFFFFFF1", buffer);
 
   AssignHexString(&bignum, "FFFFFFFFFFFFFFFF");
-  bignum.MultiplyByUInt64(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF));
+  bignum.MultiplyByUInt64(DOUBLE_CONVERSION_UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF));
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("FFFFFFFFFFFFFFFE0000000000000001", buffer);
 
@@ -635,12 +635,12 @@ TEST(MultiplyUInt64) {
   bignum.AssignUInt16(0xFFFF);
   bignum.ShiftLeft(100);
   // "FFFF0 0000 0000 0000 0000 0000 0000"
-  bignum.MultiplyByUInt64(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF));
+  bignum.MultiplyByUInt64(DOUBLE_CONVERSION_UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF));
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("FFFEFFFFFFFFFFFF00010000000000000000000000000", buffer);
 
   AssignDecimalString(&bignum, "15611230384529777");
-  bignum.MultiplyByUInt64(UINT64_2PART_C(0x8ac72304, 89e80000));
+  bignum.MultiplyByUInt64(DOUBLE_CONVERSION_UINT64_2PART_C(0x8ac72304, 89e80000));
   CHECK(bignum.ToHexString(buffer, kBufferSize));
   CHECK_EQ("1E10EE4B11D15A7F3DE7F3C7680000", buffer);
 }
diff --git a/test/cctest/test-conversions.cc b/test/cctest/test-conversions.cc
index 014dd5e..e811739 100644
--- a/test/cctest/test-conversions.cc
+++ b/test/cctest/test-conversions.cc
@@ -352,8 +352,8 @@ TEST(DoubleToFixed) {
   CHECK(dc.ToFixed(-0.0, 1, &builder));
   CHECK_EQ("0.0", builder.Finalize());
 
-  ASSERT(DoubleToStringConverter::kMaxFixedDigitsBeforePoint == 60);
-  ASSERT(DoubleToStringConverter::kMaxFixedDigitsAfterPoint == 60);
+  DOUBLE_CONVERSION_ASSERT(DoubleToStringConverter::kMaxFixedDigitsBeforePoint == 60);
+  DOUBLE_CONVERSION_ASSERT(DoubleToStringConverter::kMaxFixedDigitsAfterPoint == 60);
   builder.Reset();
   CHECK(dc.ToFixed(
       0.0, DoubleToStringConverter::kMaxFixedDigitsAfterPoint, &builder));
@@ -638,7 +638,7 @@ TEST(DoubleToExponential) {
   CHECK(dc.ToExponential(-0.0, 2, &builder));
   CHECK_EQ("0.00e+0", builder.Finalize());
 
-  ASSERT(DoubleToStringConverter::kMaxExponentialDigits == 120);
+  DOUBLE_CONVERSION_ASSERT(DoubleToStringConverter::kMaxExponentialDigits == 120);
   builder.Reset();
   CHECK(dc.ToExponential(
       0.0, DoubleToStringConverter::kMaxExponentialDigits, &builder));
@@ -765,7 +765,7 @@ TEST(DoubleToPrecision) {
                              0, 0,   // Padding zeroes for shortest mode.
                              6, 0);  // Padding zeroes for precision mode.
 
-  ASSERT(DoubleToStringConverter::kMinPrecisionDigits == 1);
+  DOUBLE_CONVERSION_ASSERT(DoubleToStringConverter::kMinPrecisionDigits == 1);
   CHECK(dc.ToPrecision(0.0, 1, &builder));
   CHECK_EQ("0", builder.Finalize());
 
@@ -781,7 +781,7 @@ TEST(DoubleToPrecision) {
   CHECK(dc.ToPrecision(-0.0, 2, &builder));
   CHECK_EQ("0.0", builder.Finalize());
 
-  ASSERT(DoubleToStringConverter::kMaxPrecisionDigits == 120);
+  DOUBLE_CONVERSION_ASSERT(DoubleToStringConverter::kMaxPrecisionDigits == 120);
   builder.Reset();
   CHECK(dc.ToPrecision(
       0.0, DoubleToStringConverter::kMaxPrecisionDigits, &builder));
@@ -1752,7 +1752,7 @@ static double StrToD16(const char* str, int flags,
       break;
     }
   }
-  ASSERT(length < 256);
+  DOUBLE_CONVERSION_ASSERT(length < 256);
   StringToDoubleConverter converter(flags, empty_string_value, Double::NaN(),
                                     NULL, NULL, separator);
   double result =
@@ -1773,7 +1773,7 @@ static double StrToD(const char* str, int flags, double empty_string_value,
       ((strlen(str) == static_cast<unsigned>(*processed_characters_count)));
 
   uc16 buffer16[256];
-  ASSERT(strlen(str) < ARRAY_SIZE(buffer16));
+  DOUBLE_CONVERSION_ASSERT(strlen(str) < DOUBLE_CONVERSION_ARRAY_SIZE(buffer16));
   int len = strlen(str);
   for (int i = 0; i < len; i++) {
     buffer16[i] = str[i];
@@ -3898,7 +3898,7 @@ static double StrToF(const char* str, int flags, double empty_string_value,
       ((strlen(str) == static_cast<unsigned>(*processed_characters_count)));
 
   uc16 buffer16[256];
-  ASSERT(strlen(str) < ARRAY_SIZE(buffer16));
+  DOUBLE_CONVERSION_ASSERT(strlen(str) < DOUBLE_CONVERSION_ARRAY_SIZE(buffer16));
   int len = strlen(str);
   for (int i = 0; i < len; i++) {
     buffer16[i] = str[i];
@@ -5531,7 +5531,7 @@ TEST(StringToDoubleFloatWhitespace) {
     kFigureSpace, kPunctuationSpace, kThinSpace, kHairSpace,
     kNarrowNoBreakSpace, kMediumMathematicalSpace, kIdeographicSpace,
   };
-  const int kWhitespace16Length = ARRAY_SIZE(kWhitespace16);
+  const int kWhitespace16Length = DOUBLE_CONVERSION_ARRAY_SIZE(kWhitespace16);
   CHECK_EQ(-1.2, StrToD16(kWhitespace16, kWhitespace16Length, flags,
                           Double::NaN(),
                           &processed, &all_used));
diff --git a/test/cctest/test-diy-fp.cc b/test/cctest/test-diy-fp.cc
index 26038b1..16209a9 100644
--- a/test/cctest/test-diy-fp.cc
+++ b/test/cctest/test-diy-fp.cc
@@ -34,20 +34,20 @@ TEST(Multiply) {
   CHECK(0 == diy_fp1.f());  // NOLINT
   CHECK_EQ(64, diy_fp1.e());
 
-  diy_fp1 = DiyFp(UINT64_2PART_C(0x80000000, 00000000), 11);
+  diy_fp1 = DiyFp(DOUBLE_CONVERSION_UINT64_2PART_C(0x80000000, 00000000), 11);
   diy_fp2 = DiyFp(2, 13);
   product = DiyFp::Times(diy_fp1, diy_fp2);
   CHECK(1 == product.f());  // NOLINT
   CHECK_EQ(11 + 13 + 64, product.e());
 
   // Test rounding.
-  diy_fp1 = DiyFp(UINT64_2PART_C(0x80000000, 00000001), 11);
+  diy_fp1 = DiyFp(DOUBLE_CONVERSION_UINT64_2PART_C(0x80000000, 00000001), 11);
   diy_fp2 = DiyFp(1, 13);
   product = DiyFp::Times(diy_fp1, diy_fp2);
   CHECK(1 == product.f());  // NOLINT
   CHECK_EQ(11 + 13 + 64, product.e());
 
-  diy_fp1 = DiyFp(UINT64_2PART_C(0x7fffffff, ffffffff), 11);
+  diy_fp1 = DiyFp(DOUBLE_CONVERSION_UINT64_2PART_C(0x7fffffff, ffffffff), 11);
   diy_fp2 = DiyFp(1, 13);
   product = DiyFp::Times(diy_fp1, diy_fp2);
   CHECK(0 == product.f());  // NOLINT
@@ -56,10 +56,10 @@ TEST(Multiply) {
   // Halfway cases are allowed to round either way. So don't check for it.
 
   // Big numbers.
-  diy_fp1 = DiyFp(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF), 11);
-  diy_fp2 = DiyFp(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF), 13);
+  diy_fp1 = DiyFp(DOUBLE_CONVERSION_UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF), 11);
+  diy_fp2 = DiyFp(DOUBLE_CONVERSION_UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF), 13);
   // 128bit result: 0xfffffffffffffffe0000000000000001
   product = DiyFp::Times(diy_fp1, diy_fp2);
-  CHECK(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFe) == product.f());
+  CHECK(DOUBLE_CONVERSION_UINT64_2PART_C(0xFFFFFFFF, FFFFFFFe) == product.f());
   CHECK_EQ(11 + 13 + 64, product.e());
 }
diff --git a/test/cctest/test-dtoa.cc b/test/cctest/test-dtoa.cc
index 0346336..494850e 100644
--- a/test/cctest/test-dtoa.cc
+++ b/test/cctest/test-dtoa.cc
@@ -269,7 +269,7 @@ TEST(DtoaVariousDoubles) {
   CHECK_EQ("35844466", buffer.start());
   CHECK_EQ(299, point);
 
-  uint64_t smallest_normal64 = UINT64_2PART_C(0x00100000, 00000000);
+  uint64_t smallest_normal64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x00100000, 00000000);
   double v = Double(smallest_normal64).value();
   DoubleToAscii(v, SHORTEST, 0, buffer, &sign, &length, &point);
   CHECK_EQ("22250738585072014", buffer.start());
@@ -287,7 +287,7 @@ TEST(DtoaVariousDoubles) {
   CHECK_EQ("22250738585072013831", buffer.start());
   CHECK_EQ(-307, point);
 
-  uint64_t largest_denormal64 = UINT64_2PART_C(0x000FFFFF, FFFFFFFF);
+  uint64_t largest_denormal64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x000FFFFF, FFFFFFFF);
   v = Double(largest_denormal64).value();
   DoubleToAscii(v, SHORTEST, 0, buffer, &sign, &length, &point);
   CHECK_EQ("2225073858507201", buffer.start());
diff --git a/test/cctest/test-fast-dtoa.cc b/test/cctest/test-fast-dtoa.cc
index 31d4784..6a523cf 100644
--- a/test/cctest/test-fast-dtoa.cc
+++ b/test/cctest/test-fast-dtoa.cc
@@ -79,7 +79,7 @@ TEST(FastDtoaShortestVariousDoubles) {
     CHECK_EQ(299, point);
   }
 
-  uint64_t smallest_normal64 = UINT64_2PART_C(0x00100000, 00000000);
+  uint64_t smallest_normal64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x00100000, 00000000);
   double v = Double(smallest_normal64).value();
   status = FastDtoa(v, FAST_DTOA_SHORTEST, 0, buffer, &length, &point);
   if (status) {
@@ -87,7 +87,7 @@ TEST(FastDtoaShortestVariousDoubles) {
     CHECK_EQ(-307, point);
   }
 
-  uint64_t largest_denormal64 = UINT64_2PART_C(0x000FFFFF, FFFFFFFF);
+  uint64_t largest_denormal64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x000FFFFF, FFFFFFFF);
   v = Double(largest_denormal64).value();
   status = FastDtoa(v, FAST_DTOA_SHORTEST, 0, buffer, &length, &point);
   if (status) {
@@ -244,14 +244,14 @@ TEST(FastDtoaPrecisionVariousDoubles) {
   CHECK_EQ("35844466", buffer.start());
   CHECK_EQ(299, point);
 
-  uint64_t smallest_normal64 = UINT64_2PART_C(0x00100000, 00000000);
+  uint64_t smallest_normal64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x00100000, 00000000);
   double v = Double(smallest_normal64).value();
   status = FastDtoa(v, FAST_DTOA_PRECISION, 17, buffer, &length, &point);
   CHECK(status);
   CHECK_EQ("22250738585072014", buffer.start());
   CHECK_EQ(-307, point);
 
-  uint64_t largest_denormal64 = UINT64_2PART_C(0x000FFFFF, FFFFFFFF);
+  uint64_t largest_denormal64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x000FFFFF, FFFFFFFF);
   v = Double(largest_denormal64).value();
   status = FastDtoa(v, FAST_DTOA_PRECISION, 17, buffer, &length, &point);
   CHECK(status);
diff --git a/test/cctest/test-ieee.cc b/test/cctest/test-ieee.cc
index c57e8ce..f5285a3 100644
--- a/test/cctest/test-ieee.cc
+++ b/test/cctest/test-ieee.cc
@@ -13,13 +13,13 @@ using namespace double_conversion;
 
 TEST(Uint64Conversions) {
   // Start by checking the byte-order.
-  uint64_t ordered = UINT64_2PART_C(0x01234567, 89ABCDEF);
+  uint64_t ordered = DOUBLE_CONVERSION_UINT64_2PART_C(0x01234567, 89ABCDEF);
   CHECK_EQ(3512700564088504e-318, Double(ordered).value());
 
-  uint64_t min_double64 = UINT64_2PART_C(0x00000000, 00000001);
+  uint64_t min_double64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x00000000, 00000001);
   CHECK_EQ(5e-324, Double(min_double64).value());
 
-  uint64_t max_double64 = UINT64_2PART_C(0x7fefffff, ffffffff);
+  uint64_t max_double64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x7fefffff, ffffffff);
   CHECK_EQ(1.7976931348623157e308, Double(max_double64).value());
 }
 
@@ -38,22 +38,22 @@ TEST(Uint32Conversions) {
 
 
 TEST(Double_AsDiyFp) {
-  uint64_t ordered = UINT64_2PART_C(0x01234567, 89ABCDEF);
+  uint64_t ordered = DOUBLE_CONVERSION_UINT64_2PART_C(0x01234567, 89ABCDEF);
   DiyFp diy_fp = Double(ordered).AsDiyFp();
   CHECK_EQ(0x12 - 0x3FF - 52, diy_fp.e());
   // The 52 mantissa bits, plus the implicit 1 in bit 52 as a UINT64.
-  CHECK(UINT64_2PART_C(0x00134567, 89ABCDEF) == diy_fp.f());  // NOLINT
+  CHECK(DOUBLE_CONVERSION_UINT64_2PART_C(0x00134567, 89ABCDEF) == diy_fp.f());  // NOLINT
 
-  uint64_t min_double64 = UINT64_2PART_C(0x00000000, 00000001);
+  uint64_t min_double64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x00000000, 00000001);
   diy_fp = Double(min_double64).AsDiyFp();
   CHECK_EQ(-0x3FF - 52 + 1, diy_fp.e());
   // This is a denormal; so no hidden bit.
   CHECK(1 == diy_fp.f());  // NOLINT
 
-  uint64_t max_double64 = UINT64_2PART_C(0x7fefffff, ffffffff);
+  uint64_t max_double64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x7fefffff, ffffffff);
   diy_fp = Double(max_double64).AsDiyFp();
   CHECK_EQ(0x7FE - 0x3FF - 52, diy_fp.e());
-  CHECK(UINT64_2PART_C(0x001fffff, ffffffff) == diy_fp.f());  // NOLINT
+  CHECK(DOUBLE_CONVERSION_UINT64_2PART_C(0x001fffff, ffffffff) == diy_fp.f());  // NOLINT
 }
 
 
@@ -78,32 +78,32 @@ TEST(Single_AsDiyFp) {
 
 
 TEST(AsNormalizedDiyFp) {
-  uint64_t ordered = UINT64_2PART_C(0x01234567, 89ABCDEF);
+  uint64_t ordered = DOUBLE_CONVERSION_UINT64_2PART_C(0x01234567, 89ABCDEF);
   DiyFp diy_fp = Double(ordered).AsNormalizedDiyFp();
   CHECK_EQ(0x12 - 0x3FF - 52 - 11, diy_fp.e());
-  CHECK((UINT64_2PART_C(0x00134567, 89ABCDEF) << 11) ==
+  CHECK((DOUBLE_CONVERSION_UINT64_2PART_C(0x00134567, 89ABCDEF) << 11) ==
         diy_fp.f());  // NOLINT
 
-  uint64_t min_double64 = UINT64_2PART_C(0x00000000, 00000001);
+  uint64_t min_double64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x00000000, 00000001);
   diy_fp = Double(min_double64).AsNormalizedDiyFp();
   CHECK_EQ(-0x3FF - 52 + 1 - 63, diy_fp.e());
   // This is a denormal; so no hidden bit.
-  CHECK(UINT64_2PART_C(0x80000000, 00000000) == diy_fp.f());  // NOLINT
+  CHECK(DOUBLE_CONVERSION_UINT64_2PART_C(0x80000000, 00000000) == diy_fp.f());  // NOLINT
 
-  uint64_t max_double64 = UINT64_2PART_C(0x7fefffff, ffffffff);
+  uint64_t max_double64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x7fefffff, ffffffff);
   diy_fp = Double(max_double64).AsNormalizedDiyFp();
   CHECK_EQ(0x7FE - 0x3FF - 52 - 11, diy_fp.e());
-  CHECK((UINT64_2PART_C(0x001fffff, ffffffff) << 11) ==
+  CHECK((DOUBLE_CONVERSION_UINT64_2PART_C(0x001fffff, ffffffff) << 11) ==
         diy_fp.f());  // NOLINT
 }
 
 
 TEST(Double_IsDenormal) {
-  uint64_t min_double64 = UINT64_2PART_C(0x00000000, 00000001);
+  uint64_t min_double64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x00000000, 00000001);
   CHECK(Double(min_double64).IsDenormal());
-  uint64_t bits = UINT64_2PART_C(0x000FFFFF, FFFFFFFF);
+  uint64_t bits = DOUBLE_CONVERSION_UINT64_2PART_C(0x000FFFFF, FFFFFFFF);
   CHECK(Double(bits).IsDenormal());
-  bits = UINT64_2PART_C(0x00100000, 00000000);
+  bits = DOUBLE_CONVERSION_UINT64_2PART_C(0x00100000, 00000000);
   CHECK(!Double(bits).IsDenormal());
 }
 
@@ -122,7 +122,7 @@ TEST(Double_IsSpecial) {
   CHECK(Double(Double::Infinity()).IsSpecial());
   CHECK(Double(-Double::Infinity()).IsSpecial());
   CHECK(Double(Double::NaN()).IsSpecial());
-  uint64_t bits = UINT64_2PART_C(0xFFF12345, 00000000);
+  uint64_t bits = DOUBLE_CONVERSION_UINT64_2PART_C(0xFFF12345, 00000000);
   CHECK(Double(bits).IsSpecial());
   // Denormals are not special:
   CHECK(!Double(5e-324).IsSpecial());
@@ -172,7 +172,7 @@ TEST(Double_IsInfinite) {
   CHECK(!Double(-0.0).IsInfinite());
   CHECK(!Double(1.0).IsInfinite());
   CHECK(!Double(-1.0).IsInfinite());
-  uint64_t min_double64 = UINT64_2PART_C(0x00000000, 00000001);
+  uint64_t min_double64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x00000000, 00000001);
   CHECK(!Double(min_double64).IsInfinite());
 }
 
@@ -192,7 +192,7 @@ TEST(Single_IsInfinite) {
 
 TEST(Double_IsNan) {
   CHECK(Double(Double::NaN()).IsNan());
-  uint64_t other_nan = UINT64_2PART_C(0xFFFFFFFF, 00000001);
+  uint64_t other_nan = DOUBLE_CONVERSION_UINT64_2PART_C(0xFFFFFFFF, 00000001);
   CHECK(Double(other_nan).IsNan());
   CHECK(!Double(Double::Infinity()).IsNan());
   CHECK(!Double(-Double::Infinity()).IsNan());
@@ -200,7 +200,7 @@ TEST(Double_IsNan) {
   CHECK(!Double(-0.0).IsNan());
   CHECK(!Double(1.0).IsNan());
   CHECK(!Double(-1.0).IsNan());
-  uint64_t min_double64 = UINT64_2PART_C(0x00000000, 00000001);
+  uint64_t min_double64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x00000000, 00000001);
   CHECK(!Double(min_double64).IsNan());
 }
 
@@ -226,7 +226,7 @@ TEST(Double_Sign) {
   CHECK_EQ(-1, Double(-Double::Infinity()).Sign());
   CHECK_EQ(1, Double(0.0).Sign());
   CHECK_EQ(-1, Double(-0.0).Sign());
-  uint64_t min_double64 = UINT64_2PART_C(0x00000000, 00000001);
+  uint64_t min_double64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x00000000, 00000001);
   CHECK_EQ(1, Double(min_double64).Sign());
 }
 
@@ -264,7 +264,7 @@ TEST(Double_NormalizedBoundaries) {
   CHECK((1 << 9) == diy_fp.f() - boundary_minus.f());  // NOLINT
   CHECK((1 << 10) == boundary_plus.f() - diy_fp.f());  // NOLINT
 
-  uint64_t min_double64 = UINT64_2PART_C(0x00000000, 00000001);
+  uint64_t min_double64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x00000000, 00000001);
   diy_fp = Double(min_double64).AsNormalizedDiyFp();
   Double(min_double64).NormalizedBoundaries(&boundary_minus, &boundary_plus);
   CHECK_EQ(diy_fp.e(), boundary_minus.e());
@@ -276,7 +276,7 @@ TEST(Double_NormalizedBoundaries) {
   CHECK((static_cast<uint64_t>(1) << 62) ==
         diy_fp.f() - boundary_minus.f());  // NOLINT
 
-  uint64_t smallest_normal64 = UINT64_2PART_C(0x00100000, 00000000);
+  uint64_t smallest_normal64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x00100000, 00000000);
   diy_fp = Double(smallest_normal64).AsNormalizedDiyFp();
   Double(smallest_normal64).NormalizedBoundaries(&boundary_minus,
                                                  &boundary_plus);
@@ -287,7 +287,7 @@ TEST(Double_NormalizedBoundaries) {
   CHECK(diy_fp.f() - boundary_minus.f() == boundary_plus.f() - diy_fp.f());
   CHECK((1 << 10) == diy_fp.f() - boundary_minus.f());  // NOLINT
 
-  uint64_t largest_denormal64 = UINT64_2PART_C(0x000FFFFF, FFFFFFFF);
+  uint64_t largest_denormal64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x000FFFFF, FFFFFFFF);
   diy_fp = Double(largest_denormal64).AsNormalizedDiyFp();
   Double(largest_denormal64).NormalizedBoundaries(&boundary_minus,
                                                   &boundary_plus);
@@ -296,7 +296,7 @@ TEST(Double_NormalizedBoundaries) {
   CHECK(diy_fp.f() - boundary_minus.f() == boundary_plus.f() - diy_fp.f());
   CHECK((1 << 11) == diy_fp.f() - boundary_minus.f());  // NOLINT
 
-  uint64_t max_double64 = UINT64_2PART_C(0x7fefffff, ffffffff);
+  uint64_t max_double64 = DOUBLE_CONVERSION_UINT64_2PART_C(0x7fefffff, ffffffff);
   diy_fp = Double(max_double64).AsNormalizedDiyFp();
   Double(max_double64).NormalizedBoundaries(&boundary_minus, &boundary_plus);
   CHECK_EQ(diy_fp.e(), boundary_minus.e());
@@ -398,7 +398,7 @@ TEST(NextDouble) {
   CHECK_EQ(4e-324, d2.NextDouble());
   CHECK_EQ(-1.7976931348623157e308, Double(-Double::Infinity()).NextDouble());
   CHECK_EQ(Double::Infinity(),
-           Double(UINT64_2PART_C(0x7fefffff, ffffffff)).NextDouble());
+           Double(DOUBLE_CONVERSION_UINT64_2PART_C(0x7fefffff, ffffffff)).NextDouble());
 }
 
 
@@ -417,5 +417,5 @@ TEST(PreviousDouble) {
   CHECK_EQ(-4e-324, d2.PreviousDouble());
   CHECK_EQ(1.7976931348623157e308, Double(Double::Infinity()).PreviousDouble());
   CHECK_EQ(-Double::Infinity(),
-           Double(UINT64_2PART_C(0xffefffff, ffffffff)).PreviousDouble());
+           Double(DOUBLE_CONVERSION_UINT64_2PART_C(0xffefffff, ffffffff)).PreviousDouble());
 }
-- 
2.29.2

